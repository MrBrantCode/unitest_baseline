{
  "task_id": "cf_44712",
  "entry_point": "minPath",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if (x, y) not in visited:",
      "mutated_line": "if (x, y) in visited:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], 1, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 1, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], -1, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], -1, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], 1, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 1, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], 0, 1))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 1))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], 0, -1))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, -1))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][0], 0, 1))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 1))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(path) == k:",
      "mutated_line": "if len(path) != k:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) != k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][1], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][1], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][-1], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][-1], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[0][1], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][1], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n or 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n or 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[1][0], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[1][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[-1][0], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[-1][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(pq, (grid[0][0], 0, 0))",
      "mutated_line": "heapq.heappush(pq, (grid[1][0], 0, 0))",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[1][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(-1, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(1, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 2), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 2), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 0), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, -1), (0, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, -1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (-1, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (1, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, +1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, +1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (2, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (2, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (0, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (-1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, -1), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, -1), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 1), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (+1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (+1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, -1)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, -1)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 1)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x - dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x - dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x * dx, y + dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x * dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y - dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y - dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y * dy)",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y * dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 < new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 < new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 > new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 > new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 == new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 == new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and 0 < new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 < new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and 0 > new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 > new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and 0 == new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 == new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -2), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -2), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -0), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, --1), (1, 0), (-1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, --1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-2, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-2, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-0, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:",
      "mutated_line": "for (dx, dy) in [(0, 1), (0, -1), (1, 0), (--1, 0)]:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (--1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 1 <= new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 1 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if -1 <= new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if -1 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 1 <= new_x < n and 0 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 1 <= new_x < n and 0 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and 1 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 1 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and -1 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and -1 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= new_x < n and 0 <= new_y < n:",
      "mutated_line": "if 0 <= new_x < n and 1 <= new_y < n:",
      "code": "import heapq\n\ndef minPath(grid, k):\n    \"\"\"\n    Determine an ordered sequence of the k smallest values route on an NxN grid.\n\n    Args:\n    grid (list): An NxN matrix where each cell holds a unique integer within 1<=N*N.\n    k (int): The number of smallest values to find.\n\n    Returns:\n    list: An ascending list of k length containing the smallest values.\n    \"\"\"\n    (pq, path, visited) = ([], [], set())\n    n = len(grid)\n    heapq.heappush(pq, (grid[0][0], 0, 0))\n    while pq:\n        (val, x, y) = heapq.heappop(pq)\n        if (x, y) not in visited:\n            visited.add((x, y))\n            path.append(val)\n            if len(path) == k:\n                return sorted(path)\n            for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                (new_x, new_y) = (x + dx, y + dy)\n                if 0 <= new_x < n and 1 <= new_y < n:\n                    heapq.heappush(pq, (grid[new_x][new_y], new_x, new_y))\n    return sorted(path)"
    }
  ]
}