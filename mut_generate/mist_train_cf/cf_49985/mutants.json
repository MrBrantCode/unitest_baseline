{
  "task_id": "cf_49985",
  "entry_point": "check_dupire_denominator_discrete",
  "mutant_count": 193,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] + strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] * strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) * delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) // delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) * (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) // (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 - strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [(1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2) * (strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i]) for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [implied_volatilities[i + 1] ** 2 * implied_volatilities[i] ** 2 / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2) * implied_volatilities[i] ** 2 / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] / delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] + delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / delta_K[i] ** delta_K[i + 1] for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 + 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 * (2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2) + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 / second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + (strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 + second_derivative[i]) for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + (strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2) ** second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d >= 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d >= 0 for d in denominator))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d <= 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d <= 0 for d in denominator))"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d != 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d != 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i - 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i * 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) + 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) * 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] * 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] + 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] * 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - (implied_volatilities[i] + 2)) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) + 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) * 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 + 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 * (2 * implied_volatilities[i + 1] ** 2) + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] * 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + (implied_volatilities[i] + 2)) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) + 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) * 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [2 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [0 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [0 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [-1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) * implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) // implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 * implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 // implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) + 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) * 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d > 1 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 1 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d > -1 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > -1 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return all(d > 0 for d in denominator)",
      "mutated_line": "return all((d > 1 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 1 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 2] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 0] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 0] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + -1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 2)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 0)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 0)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "delta_K = [strike_prices[i+1] - strike_prices[i] for i in range(len(strike_prices) - 1)]",
      "mutated_line": "second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - -1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 3 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 1 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 0 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 1 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** -2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 3) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 1) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 0) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 1) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** -2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 2)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 0)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 0)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - -1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] * 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] + 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 / implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - (2 + implied_volatilities[i + 1] ** 2) + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 ** implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 3) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 1) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 0) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 1) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** -2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i - 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i * 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 3)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 1)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 0)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 1)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - -2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 / (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - (2 + strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 ** (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / (implied_volatilities[i + 1] * 2) + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / (implied_volatilities[i + 1] + 2) + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] * 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + (strike_prices[i + 1] + 2) / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / (implied_volatilities[i + 1] * 2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / (implied_volatilities[i + 1] + 2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 3)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 1)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 0)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 1)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - -2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i - 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i * 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 3 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 1 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 0 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 1 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** -2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 3 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 1 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 0 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 1 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - -2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * (implied_volatilities[i + 1] * 2) + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * (implied_volatilities[i + 1] + 2) + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 2]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 0]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 0]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + -1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 3 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 1 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 0 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 1 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - -2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] / first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] + first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * strike_prices[i + 1] ** first_derivative[i] / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 3 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 1 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 0 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 1 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** -2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 3 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 1 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 0 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 1 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** -2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 3 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 1 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 0 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 1 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** -2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 2] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 0] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 0] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "first_derivative = [(implied_volatilities[i+1]**2 - implied_volatilities[i]**2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + -1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i - 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i * 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 3 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 1 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 0 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 1 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** -2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i - 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i * 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i - 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i * 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i - 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i * 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 3] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 1] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 0] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 1] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + -2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i - 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i * 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i - 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i * 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 2] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 0] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 0] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + -1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 2] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 0] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 0] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + -1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 2] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 0] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 0] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + -1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 2] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 0] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 0] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "second_derivative = [(implied_volatilities[i+2]**2 - 2*implied_volatilities[i+1]**2 + implied_volatilities[i]**2) / (delta_K[i] * delta_K[i+1]) for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + -1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 2] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 0] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + 0] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "denominator = [1 - 2 * (strike_prices[i+1] * first_derivative[i]) / (implied_volatilities[i+1]**2) + (strike_prices[i+1]**2 / implied_volatilities[i+1]**2) * second_derivative[i] for i in range(len(implied_volatilities) - 2)]",
      "mutated_line": "return all((d > 0 for d in denominator))",
      "code": "def check_dupire_denominator_discrete(implied_volatilities, strike_prices):\n    \"\"\"\n    Check if the discretized Dupire formula's denominator remains positive everywhere on the grid.\n\n    Parameters:\n    implied_volatilities (list): A list of discrete implied volatilities.\n    strike_prices (list): A list of corresponding strike prices.\n\n    Returns:\n    bool: True if the discretized denominator is positive everywhere, False otherwise.\n    \"\"\"\n    delta_K = [strike_prices[i + 1] - strike_prices[i] for i in range(len(strike_prices) - 1)]\n    first_derivative = [(implied_volatilities[i + 1] ** 2 - implied_volatilities[i] ** 2) / delta_K[i] for i in range(len(implied_volatilities) - 1)]\n    second_derivative = [(implied_volatilities[i + 2] ** 2 - 2 * implied_volatilities[i + 1] ** 2 + implied_volatilities[i] ** 2) / (delta_K[i] * delta_K[i + 1]) for i in range(len(implied_volatilities) - 2)]\n    denominator = [1 - 2 * (strike_prices[i + -1] * first_derivative[i]) / implied_volatilities[i + 1] ** 2 + strike_prices[i + 1] ** 2 / implied_volatilities[i + 1] ** 2 * second_derivative[i] for i in range(len(implied_volatilities) - 2)]\n    return all((d > 0 for d in denominator))"
    }
  ]
}