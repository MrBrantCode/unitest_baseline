{
  "task_id": "cf_77979",
  "entry_point": "min_median_route",
  "mutant_count": 170,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_median_route(cube):\n    \"\"\"\"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while low <= high:",
      "mutated_line": "while low < high:",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low < high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while low <= high:",
      "mutated_line": "while low > high:",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low > high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while low <= high:",
      "mutated_line": "while low == high:",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low == high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 and x >= m and (y < 0) and (y >= n) and (z < 0) and (z >= p) and (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 and x >= m and (y < 0) and (y >= n) and (z < 0) and (z >= p) and (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 or y == n - 1 or z == p - 1:",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 or y == n - 1 or z == p - 1:\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return True\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) / 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) / 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) * 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) * 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x <= 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x <= 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x >= 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x >= 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x != 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x != 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x > m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x > m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x < m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x < m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x == m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x == m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y <= 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y <= 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y >= 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y >= 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y != 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y != 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y > n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y > n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y < n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y < n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y == n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y == n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z <= 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z <= 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z >= 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z >= 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z != 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z != 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z > p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z > p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z < p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z < p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z == p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z == p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] >= median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] >= median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] <= median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] <= median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] != median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] != median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return False",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return True\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x != m - 1 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x != m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y != n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y != n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z != p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z != p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True",
      "mutated_line": "(temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return False\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low - high) // 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low - high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = low * high // 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = low * high // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 3",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 3\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 1\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 0",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 0\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 1\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // -2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // -2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(1, 0, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(1, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(-1, 0, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(-1, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(1, 0, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(1, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, 1, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 1, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, -1, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, -1, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, 1, 0, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 1, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, 0, 1, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 1, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, 0, -1, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, -1, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dfs(0, 0, 0, mid):",
      "mutated_line": "if dfs(0, 0, 1, mid):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 1, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid + 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid + 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid * 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid * 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid - 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid - 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid * 1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid * 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[1]), len(cube[0][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[1]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[-1]), len(cube[0][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[-1]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[1]), len(cube[0][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[1]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[0][1]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][1]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[0][-1]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][-1]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[0][1]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][1]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < -1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < -1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 1 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < -1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < -1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 1 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 1) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 1) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < -1) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < -1) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x < 0 or x >= m or y < 0 or y >= n or z < 0 or z >= p or cube[x][y][z] > median:",
      "mutated_line": "if x < 0 or x >= m or y < 0 or (y >= n) or (z < 1) or (z >= p) or (cube[x][y][z] > median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 1) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m + 1 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m + 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m * 1 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m * 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n + 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n + 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n * 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n * 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p + 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p + 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p * 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p * 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "temp, cube[x][y][z] = cube[x][y][z], float('inf')",
      "mutated_line": "for (dx, dy, dz) in directions:",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float(''))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x - dx, y + dy, z + dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x - dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x * dx, y + dy, z + dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x * dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x + dx, y - dy, z + dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y - dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x + dx, y * dy, z + dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y * dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x + dx, y + dy, z - dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z - dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if dfs(x + dx, y + dy, z + dz, median):",
      "mutated_line": "if dfs(x + dx, y + dy, z * dz, median):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z * dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return False\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid - 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 2\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid - 0",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 0\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid - 0",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 0\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "high = mid - 1",
      "mutated_line": "high = mid - -1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - -1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 2",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 2\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 0\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 0\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + -1",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + -1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[1][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[1][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[-1][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[-1][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "m, n, p = len(cube), len(cube[0]), len(cube[0][0])",
      "mutated_line": "(m, n, p) = (len(cube), len(cube[0]), len(cube[1][0]))",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[1][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 2 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 2 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 0 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 0 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 0 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 0 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - -1 and y == n - 1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - -1 and y == n - 1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 2 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 2 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 0 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 0 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 0 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 0 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - -1 and (z == p - 1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - -1 and (z == p - 1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p - 2):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 2):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p - 0):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 0):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p - 0):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - 0):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x == m - 1 and y == n - 1 and z == p - 1:",
      "mutated_line": "if x == m - 1 and y == n - 1 and (z == p - -1):",
      "code": "def min_median_route(cube):\n    \"\"\"\n    This function takes a 3D cube represented as a list of lists of lists where each cell is associated with a specific energy level,\n    and returns the minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n\n    Args:\n    cube (list of lists of lists): A 3D cube where each cell is associated with a specific energy level.\n\n    Returns:\n    int: The minimum median energy level of all existing routes from the top-left-front cell to the bottom-right-back cell.\n    \"\"\"\n    (m, n, p) = (len(cube), len(cube[0]), len(cube[0][0]))\n    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n\n    def dfs(x, y, z, median):\n        if x < 0 or x >= m or y < 0 or (y >= n) or (z < 0) or (z >= p) or (cube[x][y][z] > median):\n            return False\n        if x == m - 1 and y == n - 1 and (z == p - -1):\n            return True\n        (temp, cube[x][y][z]) = (cube[x][y][z], float('inf'))\n        for (dx, dy, dz) in directions:\n            if dfs(x + dx, y + dy, z + dz, median):\n                return True\n        cube[x][y][z] = temp\n        return False\n    (low, high) = (min((min((min(row) for row in plane)) for plane in cube)), max((max((max(row) for row in plane)) for plane in cube)))\n    while low <= high:\n        mid = (low + high) // 2\n        if dfs(0, 0, 0, mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low"
    }
  ]
}