{
  "task_id": "cf_17940",
  "entry_point": "binomialProb",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k == 0 and k == n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 and k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) * (math.factorial(k) * math.factorial(n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) * (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k != 0 or k == n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k != 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k == 0 or k != n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k != n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k / (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k / (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k + (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k + (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return (comb(n, k) * p ** k) ** (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return (comb(n, k) * p ** k) ** (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k / (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k / (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k + (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k + (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return (comb(n, k) * p ** k) ** (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return (comb(n, k) * p ** k) ** (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) / (math.factorial(k) / math.factorial(n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) / math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) / (math.factorial(k) + math.factorial(n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) + math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) / math.factorial(k) ** math.factorial(n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / math.factorial(k) ** math.factorial(n - k)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k == 1 or k == n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 1 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k == -1 or k == n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == -1 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if k == 0 or k == n:",
      "mutated_line": "if k == 1 or k == n:",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 1 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) / p ** k * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) / p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return (comb(n, k) + p ** k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return (comb(n, k) + p ** k) * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) ** p ** k * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) ** p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * ((1 - p) * (n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * ((1 - p) * (n - k))\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p + (n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p + (n - k))\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) / p ** k * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) / p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return (comb(n, k) + p ** k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return (comb(n, k) + p ** k) * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) ** p ** k * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) ** p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * ((1 - p) * (n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * ((1 - p) * (n - k))\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p + (n - k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p + (n - k))\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * (p * k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * (p * k) * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * (p + k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * (p + k) * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 + p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 + p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 * p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 * p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p) ** (n + k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n + k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p) ** (n * k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n * k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * (p * k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * (p * k) * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * (p + k) * (1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * (p + k) * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 + p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 + p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 * p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 * p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p) ** (n + k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n + k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (1 - p) ** (n * k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n * k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) / (math.factorial(k) * math.factorial(n + k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n + k))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return math.factorial(n)/(math.factorial(k)*math.factorial(n-k))",
      "mutated_line": "return math.factorial(n) / (math.factorial(k) * math.factorial(n * k))",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n * k))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (2 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (2 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (0 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (0 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (0 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (0 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (-1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (-1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (2 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (2 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (0 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (0 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (0 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (0 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return comb(n, k) * p**k * (1-p)**(n-k)",
      "mutated_line": "return comb(n, k) * p ** k * (-1 - p) ** (n - k)",
      "code": "def binomialProb(n, p, k):\n    \"\"\"\n    Calculate the probability of exactly k successes in n independent Bernoulli trials, \n    each with a probability of success p, using a recursive algorithm.\n\n    Parameters:\n    n (int): The total number of trials.\n    p (float): The probability of success in a single trial.\n    k (int): The number of successes.\n\n    Returns:\n    float: The probability of exactly k successes in n trials.\n    \"\"\"\n    if k == 0 or k == n:\n        return comb(n, k) * p ** k * (1 - p) ** (n - k)\n    else:\n        return comb(n, k) * p ** k * (-1 - p) ** (n - k)\nimport math\n\ndef comb(n, k):\n    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))"
    }
  ]
}