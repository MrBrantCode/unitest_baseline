{
  "task_id": "cf_95627",
  "entry_point": "k_means_clustering",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def k_means_clustering(data, k, max_iterations=100):",
      "mutated_line": "def k_means_clustering(data, k, max_iterations=101):",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=101):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def k_means_clustering(data, k, max_iterations=100):",
      "mutated_line": "def k_means_clustering(data, k, max_iterations=99):",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=99):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def k_means_clustering(data, k, max_iterations=100):",
      "mutated_line": "def k_means_clustering(data, k, max_iterations=0):",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=0):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def k_means_clustering(data, k, max_iterations=100):",
      "mutated_line": "def k_means_clustering(data, k, max_iterations=1):",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=1):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def k_means_clustering(data, k, max_iterations=100):",
      "mutated_line": "def k_means_clustering(data, k, max_iterations=-100):",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=-100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_features = data.shape[1]",
      "mutated_line": "n_features = data.shape[2]",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[2]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_features = data.shape[1]",
      "mutated_line": "n_features = data.shape[0]",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[0]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_features = data.shape[1]",
      "mutated_line": "n_features = data.shape[0]",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[0]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "n_features = data.shape[1]",
      "mutated_line": "n_features = data.shape[-1]",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[-1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] >= 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] >= 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] <= 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] <= 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] != 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] != 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "centroids_indices = np.random.choice(n_samples, k, replace=False)",
      "mutated_line": "centroids_indices = np.random.choice(n_samples, k, replace=True)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=True)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] + centroids, axis=1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] + centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] * centroids, axis=1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] * centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "cluster_points = data[clusters == cluster]",
      "mutated_line": "cluster_points = data[clusters != cluster]",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters != cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] > 1:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 1:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] > -1:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > -1:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[0] > 1:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 1:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] - centroids, axis=2)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=2)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] - centroids, axis=0)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=0)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] - centroids, axis=0)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=0)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "distances = np.linalg.norm(data[i] - centroids, axis=1)",
      "mutated_line": "distances = np.linalg.norm(data[i] - centroids, axis=-1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=-1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[1] > 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[1] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[-1] > 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[-1] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if cluster_points.shape[0] > 0:",
      "mutated_line": "if cluster_points.shape[1] > 0:",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[1] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=0)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_centroids[cluster] = np.mean(cluster_points, axis=0)",
      "mutated_line": "new_centroids[cluster] = np.mean(cluster_points, axis=1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=1)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_centroids[cluster] = np.mean(cluster_points, axis=0)",
      "mutated_line": "new_centroids[cluster] = np.mean(cluster_points, axis=-1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=-1)\n    return new_centroids"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_centroids[cluster] = np.mean(cluster_points, axis=0)",
      "mutated_line": "new_centroids[cluster] = np.mean(cluster_points, axis=1)",
      "code": "import numpy as np\n\ndef k_means_clustering(data, k, max_iterations=100):\n    centroids = initialize_centroids(data, k)\n    for _ in range(max_iterations):\n        clusters = assign_points_to_centroids(data, centroids)\n        new_centroids = update_centroids(data, clusters, k)\n        if np.allclose(centroids, new_centroids):\n            break\n        centroids = new_centroids\n    return (clusters, centroids)\n\ndef initialize_centroids(data, k):\n    (n_samples, _) = data.shape\n    centroids_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = data[centroids_indices]\n    return centroids\n\ndef assign_points_to_centroids(data, centroids):\n    (n_samples, _) = data.shape\n    clusters = np.zeros(n_samples)\n    for i in range(n_samples):\n        distances = np.linalg.norm(data[i] - centroids, axis=1)\n        cluster = np.argmin(distances)\n        clusters[i] = cluster\n    return clusters\n\ndef update_centroids(data, clusters, k):\n    n_features = data.shape[1]\n    new_centroids = np.zeros((k, n_features))\n    for cluster in range(k):\n        cluster_points = data[clusters == cluster]\n        if cluster_points.shape[0] > 0:\n            new_centroids[cluster] = np.mean(cluster_points, axis=1)\n    return new_centroids"
    }
  ]
}