{
  "task_id": "cf_28414",
  "entry_point": "parse_instruction_tests",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "test_cases = re.findall(r'fn\\s+(\\w+)\\(\\)\\s*{\\s*run_test\\(&Instruction\\s*{\\s*mnemonic:\\s*Mnemonic::(\\w+),\\s*operand1:\\s*Some\\(([^)]*)\\),\\s*operand2:\\s*Some\\(([^)]*)\\),\\s*operand3:\\s*Some\\(([^)]*)\\),\\s*operand4:\\s*([^,]*),\\s*lock:\\s*(true|false),\\s*rounding_mode:\\s*([^,]*),\\s*merge_mode:\\s*Some\\(MergeMode::(\\w+)\\),\\s*sae:\\s*(true|false),\\s*mask:\\s*Some\\(MaskReg::(\\w+)\\),\\s*broadcast:\\s*([^)]*)\\s*},\\s*&\\[\\d+,\\s*\\d+,\\s*\\d+,\\s*\\d+,\\s*\\d+,\\s*\\d+,\\s*\\d+\\],\\s*OperandSize::(\\w+)\\)\\s*}', code_snippet)",
      "mutated_line": "test_cases = re.findall('', code_snippet)",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'mnemonic': test_case[1],",
      "mutated_line": "parsed_test = {'': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], '': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], '': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], '': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], '': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], '': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], '': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], '': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], '': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], '': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], '': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, '': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, '': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], '': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], '': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], '': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], '': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, '': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, '': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], '': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], '': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], '': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], '': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'mnemonic': test_case[1],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[2], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[2], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'mnemonic': test_case[1],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[0], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[0], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'mnemonic': test_case[1],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[0], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[0], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'mnemonic': test_case[1],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[-1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[-1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[3], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[3], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[1], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[1], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[0], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[0], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[1], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[1], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "'operand1': test_case[2],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[-2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[-2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[4], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[4], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[2], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[2], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[0], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[0], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[1], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[1], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "'operand2': test_case[3],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[-3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[-3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[5], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[5], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[3], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[3], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[0], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[0], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[1], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[1], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "'operand3': test_case[4],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[-4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[-4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[6], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[6], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[4], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[4], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[0], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[0], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[1], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[1], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'operand4': test_case[5],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[-5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[-5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] != 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] != 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': False if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': False if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else True, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else True, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[8], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[8], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[6], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[6], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[0], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[0], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[1], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[1], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'rounding_mode': test_case[7],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[-7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[-7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[9], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[9], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[7], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[7], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[0], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[0], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[1], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[1], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'merge_mode': test_case[8],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[-8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[-8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] != 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] != 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': False if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': False if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else True, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else True, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[11], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[11], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[9], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[9], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[0], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[0], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[1], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[1], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'mask': test_case[10],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[-10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[-10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[12], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[12], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[10], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[10], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[0], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[0], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[1], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[1], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "'broadcast': test_case[11],",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[-11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[-11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[13]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[13]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[11]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[11]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[0]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[0]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[1]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[1]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "'operand_size': test_case[12]",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[-12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[-12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == '' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == '' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == '' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == '' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[7] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[7] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[5] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[5] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[0] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[0] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[1] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[1] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'lock': True if test_case[6] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[-6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[-6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[10] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[10] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[8] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[8] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[0] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[0] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[1] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[1] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'sae': True if test_case[9] == 'true' else False,",
      "mutated_line": "parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[-9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}",
      "code": "from typing import List, Dict, Union\nimport re\n\ndef parse_instruction_tests(code_snippet: str) -> List[Dict[str, Union[str, bool, None]]]:\n    test_cases = re.findall('fn\\\\s+(\\\\w+)\\\\(\\\\)\\\\s*{\\\\s*run_test\\\\(&Instruction\\\\s*{\\\\s*mnemonic:\\\\s*Mnemonic::(\\\\w+),\\\\s*operand1:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand2:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand3:\\\\s*Some\\\\(([^)]*)\\\\),\\\\s*operand4:\\\\s*([^,]*),\\\\s*lock:\\\\s*(true|false),\\\\s*rounding_mode:\\\\s*([^,]*),\\\\s*merge_mode:\\\\s*Some\\\\(MergeMode::(\\\\w+)\\\\),\\\\s*sae:\\\\s*(true|false),\\\\s*mask:\\\\s*Some\\\\(MaskReg::(\\\\w+)\\\\),\\\\s*broadcast:\\\\s*([^)]*)\\\\s*},\\\\s*&\\\\[\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+,\\\\s*\\\\d+\\\\],\\\\s*OperandSize::(\\\\w+)\\\\)\\\\s*}', code_snippet)\n    parsed_tests = []\n    for test_case in test_cases:\n        parsed_test = {'mnemonic': test_case[1], 'operand1': test_case[2], 'operand2': test_case[3], 'operand3': test_case[4], 'operand4': test_case[5], 'lock': True if test_case[6] == 'true' else False, 'rounding_mode': test_case[7], 'merge_mode': test_case[8], 'sae': True if test_case[-9] == 'true' else False, 'mask': test_case[10], 'broadcast': test_case[11], 'operand_size': test_case[12]}\n        parsed_tests.append(parsed_test)\n    return parsed_tests"
    }
  ]
}