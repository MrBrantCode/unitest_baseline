{
  "task_id": "cf_56054",
  "entry_point": "a_star_search",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while cameFrom[current] is not None:",
      "mutated_line": "while cameFrom[current] is None:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gScores = {start: 0}",
      "mutated_line": "gScores = {start: 1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 1}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gScores = {start: 0}",
      "mutated_line": "gScores = {start: -1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: -1}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gScores = {start: 0}",
      "mutated_line": "gScores = {start: 1}",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 1}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if currentNode == goal:",
      "mutated_line": "if currentNode != goal:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode != goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heapq.heappush(openList, (0, start))",
      "mutated_line": "heapq.heappush(openList, (1, start))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (1, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heapq.heappush(openList, (0, start))",
      "mutated_line": "heapq.heappush(openList, (-1, start))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (-1, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "heapq.heappush(openList, (0, start))",
      "mutated_line": "heapq.heappush(openList, (1, start))",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (1, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if neighbor in closedList:",
      "mutated_line": "if neighbor not in closedList:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor not in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores and gScores[currentNode] + weight < gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores and gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "total_path.insert(0, current)",
      "mutated_line": "total_path.insert(1, current)",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(1, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "total_path.insert(0, current)",
      "mutated_line": "total_path.insert(-1, current)",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(-1, current)\n    return total_path"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "total_path.insert(0, current)",
      "mutated_line": "total_path.insert(1, current)",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(1, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores or gScores[currentNode] + weight <= gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight <= gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores or gScores[currentNode] + weight >= gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight >= gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores or gScores[currentNode] + weight != gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight != gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "gScores[neighbor] = gScores[currentNode] + weight",
      "mutated_line": "gScores[neighbor] = gScores[currentNode] - weight",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] - weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "gScores[neighbor] = gScores[currentNode] + weight",
      "mutated_line": "gScores[neighbor] = gScores[currentNode] * weight",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] * weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)",
      "mutated_line": "fScores[neighbor] = gScores[neighbor] - heuristic(neighbor, goal)",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] - heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)",
      "mutated_line": "fScores[neighbor] = gScores[neighbor] * heuristic(neighbor, goal)",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] * heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores or gScores[currentNode] - weight < gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] - weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if neighbor not in gScores or gScores[currentNode] + weight < gScores[neighbor]:",
      "mutated_line": "if neighbor not in gScores or gScores[currentNode] * weight < gScores[neighbor]:",
      "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    openList = []\n    heapq.heappush(openList, (0, start))\n    closedList = set()\n    gScores = {start: 0}\n    fScores = {start: heuristic(start, goal)}\n    cameFrom = {start: None}\n    while openList:\n        (_, currentNode) = heapq.heappop(openList)\n        if currentNode == goal:\n            return reconstruct_path(cameFrom, currentNode)\n        closedList.add(currentNode)\n        for (neighbor, weight) in graph[currentNode].items():\n            if neighbor in closedList:\n                continue\n            if neighbor not in gScores or gScores[currentNode] * weight < gScores[neighbor]:\n                gScores[neighbor] = gScores[currentNode] + weight\n                fScores[neighbor] = gScores[neighbor] + heuristic(neighbor, goal)\n                cameFrom[neighbor] = currentNode\n                heapq.heappush(openList, (fScores[neighbor], neighbor))\n    return None\n\ndef reconstruct_path(cameFrom, current):\n    total_path = [current]\n    while cameFrom[current] is not None:\n        current = cameFrom[current]\n        total_path.insert(0, current)\n    return total_path"
    }
  ]
}