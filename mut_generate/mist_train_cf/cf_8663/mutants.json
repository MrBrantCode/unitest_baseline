{
  "task_id": "cf_8663",
  "entry_point": "divideList",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "m = -(-len(lst) // n)",
      "mutated_line": "m = +(-len(lst) // n)",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = +(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distinct_count = 0",
      "mutated_line": "distinct_count = 1",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 1\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distinct_count = 0",
      "mutated_line": "distinct_count = -1",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = -1\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distinct_count = 0",
      "mutated_line": "distinct_count = 1",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 1\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "distinct_count += len(set(group))",
      "mutated_line": "distinct_count -= len(set(group))",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count -= len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "m = -(-len(lst) // n)",
      "mutated_line": "m = -(-len(lst) / n)",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) / n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "m = -(-len(lst) // n)",
      "mutated_line": "m = -(-len(lst) * n)",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) * n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "start = i * m",
      "mutated_line": "start = i / m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i / m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "start = i * m",
      "mutated_line": "start = i + m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i + m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "start = i * m",
      "mutated_line": "start = i ** m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i ** m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + 1) / m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) / m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = i + 1 + m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = i + 1 + m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + 1) ** m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) ** m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if end > len(lst):",
      "mutated_line": "if end >= len(lst):",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end >= len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if end > len(lst):",
      "mutated_line": "if end <= len(lst):",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end <= len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if end > len(lst):",
      "mutated_line": "if end != len(lst):",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end != len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "m = -(-len(lst) // n)",
      "mutated_line": "m = -(+len(lst) // n)",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(+len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i - 1) * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i - 1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = i * 1 * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = i * 1 * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + 2) * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 2) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + 0) * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 0) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + 0) * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + 0) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "end = (i + 1) * m",
      "mutated_line": "end = (i + -1) * m",
      "code": "def divideList(lst, n):\n    lst.sort()\n    m = -(-len(lst) // n)\n    groups = []\n    distinct_count = 0\n    for i in range(n):\n        start = i * m\n        end = (i + -1) * m\n        if end > len(lst):\n            end = len(lst)\n        group = lst[start:end]\n        groups.append(group)\n        distinct_count += len(set(group))\n    return (groups, distinct_count)"
    }
  ]
}