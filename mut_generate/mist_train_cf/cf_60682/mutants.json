{
  "task_id": "cf_60682",
  "entry_point": "maxSumPath",
  "mutant_count": 104,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 and y < 0 and (x >= len(grid)) and (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 and y < 0 and (x >= len(grid)) and (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if cell in visited_cells:",
      "mutated_line": "if cell not in visited_cells:",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell not in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return False\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if steps_left == 0:",
      "mutated_line": "if steps_left != 0:",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left != 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max_sum_path[0]",
      "mutated_line": "return max_sum_path[1]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max_sum_path[0]",
      "mutated_line": "return max_sum_path[-1]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return max_sum_path[0]",
      "mutated_line": "return max_sum_path[1]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[1])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[-1])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[-1])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[1])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x <= 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x <= 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x >= 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x >= 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x != 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x != 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y <= 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y <= 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y >= 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y >= 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y != 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y != 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x > len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x > len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x < len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x < len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x == len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x == len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y > len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y > len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y < len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y < len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y == len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y == len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return True\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return True\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if steps_left == 0:",
      "mutated_line": "if steps_left == 1:",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 1:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if steps_left == 0:",
      "mutated_line": "if steps_left == -1:",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == -1:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if steps_left == 0:",
      "mutated_line": "if steps_left == 1:",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 1:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path >= sum(max_sum_path[0]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path >= sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path <= sum(max_sum_path[0]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path <= sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path != sum(max_sum_path[0]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path != sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[0][1]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][1]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[0][-1]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][-1]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[0][1]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][1]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < -1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < -1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 1 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 1 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 1 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < -1 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < -1 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 1 or x >= len(grid) or (y >= len(grid[0])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 1 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_cell = (x+dx, y+dy)",
      "mutated_line": "next_cell = (x - dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x - dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_cell = (x+dx, y+dy)",
      "mutated_line": "next_cell = (x * dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x * dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_cell = (x+dx, y+dy)",
      "mutated_line": "next_cell = (x + dx, y - dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y - dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "next_cell = (x+dx, y+dy)",
      "mutated_line": "next_cell = (x + dx, y * dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y * dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k + 1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k + 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k * 1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k * 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[1][0]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[1][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[-1][0]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[-1][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "max_sum_path = [[grid[0][0]]]",
      "mutated_line": "max_sum_path = [[grid[1][0]]]",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[1][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_sum_path[0] = path.copy()",
      "mutated_line": "max_sum_path[1] = path.copy()",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[1] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_sum_path[0] = path.copy()",
      "mutated_line": "max_sum_path[-1] = path.copy()",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[-1] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "max_sum_path[0] = path.copy()",
      "mutated_line": "max_sum_path[1] = path.copy()",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[1] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for dx, dy in [(-1,0), (1,0), (0, -1), (0, 1)]:",
      "mutated_line": "next_cell = (x + dx, y + dy)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left + 1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left + 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left * 1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left * 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k - 2, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 2, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k - 0, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 0, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k - 0, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 0, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dfs((i, j), k-1, visited_cells, path)",
      "mutated_line": "dfs((i, j), k - -1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - -1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[1])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[1])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[-1])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[-1])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x<0 or y<0 or x>=len(grid) or y>=len(grid[0]):",
      "mutated_line": "if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[1])):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[1])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path > sum(max_sum_path[1]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[1]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path > sum(max_sum_path[-1]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[-1]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if sum_path > sum(max_sum_path[0]):",
      "mutated_line": "if sum_path > sum(max_sum_path[1]):",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[1]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left - 2, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 2, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left - 0, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 0, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left - 0, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - 0, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dfs(next_cell, steps_left-1, visited_cells, path)",
      "mutated_line": "dfs(next_cell, steps_left - -1, visited_cells, path)",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[1]])\n                dfs(next_cell, steps_left - -1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[0]][next_cell[2]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[2]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[0]][next_cell[0]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[0]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[0]][next_cell[0]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[0]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[0]][next_cell[-1]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[0]][next_cell[-1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[1]][next_cell[1]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[1]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[-1]][next_cell[1]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[-1]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "path.append(grid[next_cell[0]][next_cell[1]])",
      "mutated_line": "path.append(grid[next_cell[1]][next_cell[1]])",
      "code": "def maxSumPath(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    max_sum_path = [[grid[0][0]]]\n\n    def is_valid(cell, visited_cells):\n        (x, y) = cell\n        if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n            return False\n        if cell in visited_cells:\n            return False\n        return True\n\n    def dfs(cell, steps_left, visited_cells, path):\n        if steps_left == 0:\n            sum_path = sum(path)\n            if sum_path > sum(max_sum_path[0]):\n                max_sum_path[0] = path.copy()\n            return\n        (x, y) = cell\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            next_cell = (x + dx, y + dy)\n            if is_valid(next_cell, visited_cells):\n                visited_cells.add(next_cell)\n                path.append(grid[next_cell[1]][next_cell[1]])\n                dfs(next_cell, steps_left - 1, visited_cells, path)\n                path.pop()\n                visited_cells.remove(next_cell)\n    for i in range(n):\n        for j in range(m):\n            visited_cells = {(i, j)}\n            path = [grid[i][j]]\n            dfs((i, j), k - 1, visited_cells, path)\n    return max_sum_path[0]"
    }
  ]
}