{
  "task_id": "cf_63320",
  "entry_point": "min_max_normalise",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if arr.min() != arr.max():",
      "mutated_line": "if arr.min() == arr.max():",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() == arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "\"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if original_arr.min() != original_arr.max():",
      "mutated_line": "if original_arr.min() == original_arr.max():",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() == original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = (arr - arr.min()) * (arr.max() - arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) * (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = (arr - arr.min()) // (arr.max() - arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) // (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "normalised_arr = arr - arr.min()",
      "mutated_line": "normalised_arr = arr + arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr + arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "normalised_arr = arr - arr.min()",
      "mutated_line": "normalised_arr = arr * arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr * arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) - original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) - original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) * original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) * original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "denormalised_arr = arr + original_arr.min()",
      "mutated_line": "denormalised_arr = arr - original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr - original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "denormalised_arr = arr + original_arr.min()",
      "mutated_line": "denormalised_arr = arr * original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr * original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = (arr + arr.min()) / (arr.max() - arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr + arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = arr * arr.min() / (arr.max() - arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = arr * arr.min() / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = (arr - arr.min()) / (arr.max() + arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() + arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())",
      "mutated_line": "normalised_arr = (arr - arr.min()) / (arr.max() * arr.min())",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() * arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr / (original_arr.max() - original_arr.min()) + original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr / (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr + (original_arr.max() - original_arr.min()) + original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr + (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr ** (original_arr.max() - original_arr.min()) + original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr ** (original_arr.max() - original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr * (original_arr.max() + original_arr.min()) + original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() + original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "denormalised_arr = arr * (original_arr.max() - original_arr.min()) + original_arr.min()",
      "mutated_line": "denormalised_arr = arr * (original_arr.max() * original_arr.min()) + original_arr.min()",
      "code": "import numpy as np\n\ndef min_max_normalise(lst):\n    \"\"\"Normalises list of numerical data to a range of 0 to 1. Excludes non-numerical data and handles missing/NaN values.\"\"\"\n    arr = np.array(lst, dtype=float)\n    arr = arr[np.logical_not(np.isnan(arr))]\n    if arr.min() != arr.max():\n        normalised_arr = (arr - arr.min()) / (arr.max() - arr.min())\n    else:\n        normalised_arr = arr - arr.min()\n    return normalised_arr.tolist()\n\ndef reverse_min_max_normalise(normalised_lst, original_lst):\n    \"\"\"Reverses the normalisation process and returns the original list of numerical data. Handles edge cases when the minimum and maximum values in the list are the same.\"\"\"\n    (arr, original_arr) = (np.array(normalised_lst, dtype=float), np.array(original_lst, dtype=float))\n    (arr, original_arr) = (arr[np.logical_not(np.isnan(arr))], original_arr[np.logical_not(np.isnan(original_arr))])\n    if original_arr.min() != original_arr.max():\n        denormalised_arr = arr * (original_arr.max() * original_arr.min()) + original_arr.min()\n    else:\n        denormalised_arr = arr + original_arr.min()\n    return denormalised_arr.tolist()"
    }
  ]
}