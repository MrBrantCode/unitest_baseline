{
  "task_id": "cf_83254",
  "entry_point": "jobScheduling",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) + 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) + 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) * 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) * 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p >= dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p >= dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p <= dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p <= dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p != dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p != dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-1][2]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-1][0]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-1][0]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-1][-1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[1, 0]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[1, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[-1, 0]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[-1, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[1, 0]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[1, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[0, 1]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 1]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[0, -1]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, -1]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[0, 0]]",
      "mutated_line": "dp = [[0, 1]]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 1]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) - 2",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 2\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) - 0",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 0\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) - 0",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 0\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 1]) - -1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - -1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] - p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] - p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] * p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] * p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[+1][1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[+1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-1][2]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][2]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-1][0]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][0]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-1][0]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][0]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-1][-1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][-1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-2][1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-2][1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-0][1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[-0][1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dp[-1][1]",
      "mutated_line": "return dp[--1][1]",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[--1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[-1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[-1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[1] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[2] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[2] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[0] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[0] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[0] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[0] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[-1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[-1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[3] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[3] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[1] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[1] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[0] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[0] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[1] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[1] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[-2] for i in projects]), key=lambda v: v[1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[-2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[2])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[2])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[0])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[0])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[0])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[0])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])",
      "mutated_line": "jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[-1])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[-1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s - 1]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s - 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s * 1]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s * 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][2] + p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][2] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][0] + p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][0] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][0] + p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][0] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][-1] + p > dp[-1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][-1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[+1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[+1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][1] - p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] - p])\n    return dp[-1][1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][1] * p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] * p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 2]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 2]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 0]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 0]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + 0]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 0]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = bisect.bisect(dp, [s + 1]) - 1",
      "mutated_line": "i = bisect.bisect(dp, [s + -1]) - 1",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + -1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-2][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-2][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-0][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-0][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[-0][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-0][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dp[i][1] + p > dp[-1][1]:",
      "mutated_line": "if dp[i][1] + p > dp[--1][1]:",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[--1][1]:\n            dp.append([e, dp[i][1] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][2] + p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][2] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][0] + p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][0] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][0] + p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][0] + p])\n    return dp[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp.append([e, dp[i][1] + p])",
      "mutated_line": "dp.append([e, dp[i][-1] + p])",
      "code": "from typing import List\nimport bisect\n\ndef jobScheduling(projects: List[List[int]], n: int) -> int:\n    \"\"\"\n    This function finds the maximum sum of profits that can be received by completing projects.\n    \n    Args:\n        projects (List[List[int]]): A list of projects where each project is represented as [startDay, endDay, profit].\n        n (int): The maximum number of projects that can be completed.\n        \n    Returns:\n        int: The maximum sum of profits.\n    \"\"\"\n    jobs = sorted(zip([i[0] for i in projects], [i[1] for i in projects], [i[2] for i in projects]), key=lambda v: v[1])\n    dp = [[0, 0]]\n    for (s, e, p) in jobs:\n        i = bisect.bisect(dp, [s + 1]) - 1\n        if dp[i][1] + p > dp[-1][1]:\n            dp.append([e, dp[i][-1] + p])\n    return dp[-1][1]"
    }
  ]
}