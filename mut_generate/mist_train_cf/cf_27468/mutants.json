{
  "task_id": "cf_27468",
  "entry_point": "find_path",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_path(maze):\n    \"\"\"\"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return \"No path found\"",
      "mutated_line": "return ''",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), '': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), '': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), '': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), '': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), '': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), '': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if maze[x][y] == 'E':",
      "mutated_line": "if maze[x][y] != 'E':",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] != 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (+1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (+1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, -1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, -1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 1), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (2, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (2, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (0, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (0, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (0, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (0, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (-1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (-1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 1), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 1), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, -1), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, -1), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 1), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 1), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (1, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (1, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (-1, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (-1, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (1, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (1, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, +1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, +1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (1, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (1, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (-1, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (-1, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (1, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (1, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 2)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 2)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 0)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 0)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 0)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 0)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, -1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, -1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if maze[i][j] == 'S':",
      "mutated_line": "if maze[i][j] != 'S':",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] != 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue = [(start, \"\")]",
      "mutated_line": "queue = [(start, 'MUTATED')]",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, 'MUTATED')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(x, y), path = queue.pop(0)",
      "mutated_line": "((x, y), path) = queue.pop(1)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(1)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(x, y), path = queue.pop(0)",
      "mutated_line": "((x, y), path) = queue.pop(-1)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(-1)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(x, y), path = queue.pop(0)",
      "mutated_line": "((x, y), path) = queue.pop(1)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(1)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if maze[x][y] == 'E':",
      "mutated_line": "if maze[x][y] == '':",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == '':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) or 0 <= new_y < len(maze[0]) or maze[new_x][new_y] != '#' or ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) or 0 <= new_y < len(maze[0]) or maze[new_x][new_y] != '#' or ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-2, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-2, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-0, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-0, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-0, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-0, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (--1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (--1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -2), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -2), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -0), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -0), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -0), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -0), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}",
      "mutated_line": "directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, --1), 'R': (0, 1)}",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, --1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if maze[i][j] == 'S':",
      "mutated_line": "if maze[i][j] == '':",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == '':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x - dx, y + dy)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x - dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x * dx, y + dy)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x * dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y - dy)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y - dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_x, new_y = x + dx, y + dy",
      "mutated_line": "(new_x, new_y) = (x + dx, y * dy)",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y * dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 < new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 < new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 > new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 > new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 == new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 == new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 < new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 < new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 > new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 > new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 == new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 == new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] == '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] == '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(len(maze[0])):",
      "mutated_line": "for j in range(len(maze[1])):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[1])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(len(maze[0])):",
      "mutated_line": "for j in range(len(maze[-1])):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[-1])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(len(maze[0])):",
      "mutated_line": "for j in range(len(maze[1])):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[1])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if -1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if -1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 1 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and -1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and -1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 1 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "queue.append(((new_x, new_y), path + direction))",
      "mutated_line": "queue.append(((new_x, new_y), path - direction))",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path - direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "queue.append(((new_x, new_y), path + direction))",
      "mutated_line": "queue.append(((new_x, new_y), path * direction))",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path * direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[-1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[-1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[0]) and maze[new_x][new_y] != '#' and (new_x, new_y) not in visited:",
      "mutated_line": "if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):",
      "code": "def find_path(maze):\n    \"\"\"\n    Finds a path from the start cell 'S' to the end cell 'E' in a given 2D maze grid.\n\n    Args:\n    maze (list of lists of characters): A 2D maze grid where '.' denotes an empty cell, '#' denotes a blocked cell, 'S' denotes the start cell, and 'E' denotes the end cell.\n\n    Returns:\n    str: The path as a sequence of movements: 'U' for up, 'D' for down, 'L' for left, and 'R' for right. If there is no valid path from 'S' to 'E', returns \"No path found\".\n    \"\"\"\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                start = (i, j)\n                break\n    queue = [(start, '')]\n    visited = set()\n    while queue:\n        ((x, y), path) = queue.pop(0)\n        if maze[x][y] == 'E':\n            return path\n        for (direction, (dx, dy)) in directions.items():\n            (new_x, new_y) = (x + dx, y + dy)\n            if 0 <= new_x < len(maze) and 0 <= new_y < len(maze[1]) and (maze[new_x][new_y] != '#') and ((new_x, new_y) not in visited):\n                queue.append(((new_x, new_y), path + direction))\n                visited.add((new_x, new_y))\n    return 'No path found'"
    }
  ]
}