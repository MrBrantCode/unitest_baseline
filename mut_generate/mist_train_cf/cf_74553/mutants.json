{
  "task_id": "cf_74553",
  "entry_point": "diamond_sum",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def diamond_sum(diamond):\n    \"\"\"\"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) / 2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) / 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) * 2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) * 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) < 1:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) < 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) > 1:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) > 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) == 1:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) == 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) / 2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) / 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) * 2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) * 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] <= right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] <= right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] >= right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] >= right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] != right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] != right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] - merge(left, right[1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] - merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] * merge(left, right[1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] * merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) // 3",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 3\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) // 1",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 1\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) // 0",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 0\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) // 1",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 1\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mid = len(diamond) // 2",
      "mutated_line": "mid = len(diamond) // -2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // -2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) <= 2:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 2:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) <= 0:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 0:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) <= 0:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 0:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(lst) <= 1:",
      "mutated_line": "if len(lst) <= -1:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= -1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) // 3",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 3\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) // 1",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 1\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) // 0",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 0\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) // 1",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 1\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "mid = len(lst) // 2",
      "mutated_line": "mid = len(lst) // -2",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // -2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] - merge(left[1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] - merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] * merge(left[1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] * merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= mid:",
      "mutated_line": "if i < mid:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i < mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= mid:",
      "mutated_line": "if i > mid:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i > mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= mid:",
      "mutated_line": "if i == mid:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i == mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[1] < right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[1] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[-1] < right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[-1] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[1] < right[0]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[1] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[1]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[1]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[-1]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[-1]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left[0] < right[0]:",
      "mutated_line": "if left[0] < right[1]:",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[1]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // 2 - j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 - j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = (mid - row_len // 2) * j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = (mid - row_len // 2) * j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 2 + j - (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j - (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = (mid - row_len // 2 + j) * (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = (mid - row_len // 2 + j) * (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[1]] + merge(left, right[1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[1]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[-1]] + merge(left, right[1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[-1]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[1]] + merge(left, right[1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[1]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid + row_len // 2 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid + row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid * (row_len // 2) + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid * (row_len // 2) + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 2 - j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 - j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = (mid - row_len // 2) * j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = (mid - row_len // 2) * j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 2 + j + (i + mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i + mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 2 + j + i * mid",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + i * mid\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[1]] + merge(left[1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[1]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[-1]] + merge(left[1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[-1]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[1]] + merge(left[1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[1]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] + merge(left, right[2:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[2:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] + merge(left, right[0:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[0:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] + merge(left, right[0:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[0:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return [right[0]] + merge(left, right[1:])",
      "mutated_line": "return [right[0]] + merge(left, right[-1:])",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[-1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len / 2 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len / 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len * 2 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len * 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid + row_len // 2 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid + row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid * (row_len // 2) + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid * (row_len // 2) + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] + merge(left[2:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[2:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] + merge(left[0:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[0:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] + merge(left[0:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[0:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [left[0]] + merge(left[1:], right)",
      "mutated_line": "return [left[0]] + merge(left[-1:], right)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[-1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // 3 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 3 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // 1 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 1 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // 0 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 0 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // 1 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 1 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "diagonal = mid - row_len // 2 + j",
      "mutated_line": "diagonal = mid - row_len // -2 + j",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // -2 + j\n            else:\n                diagonal = mid - row_len // 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len / 2 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len / 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len * 2 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len * 2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 3 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 3 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 1 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 1 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 0 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 0 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // 1 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // 1 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "diagonal = mid - row_len // 2 + j + (i - mid)",
      "mutated_line": "diagonal = mid - row_len // -2 + j + (i - mid)",
      "code": "def diamond_sum(diamond):\n    \"\"\"\n    This function calculates the sum of numbers in each diagonal line of a diamond-shaped grid.\n    It uses the merge sort algorithm for sorting the numbers in each diagonal line.\n\n    Args:\n    diamond (list of lists): A 2D list representing the diamond shape.\n\n    Returns:\n    int: The sum of numbers in each diagonal line of the diamond.\n    \"\"\"\n\n    def merge_sort(lst):\n        if len(lst) <= 1:\n            return lst\n        mid = len(lst) // 2\n        left = merge_sort(lst[:mid])\n        right = merge_sort(lst[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        if not left:\n            return right\n        if not right:\n            return left\n        if left[0] < right[0]:\n            return [left[0]] + merge(left[1:], right)\n        return [right[0]] + merge(left, right[1:])\n    mid = len(diamond) // 2\n    diagonal_lines = [[] for _ in range(len(diamond))]\n    for (i, row) in enumerate(diamond):\n        row_len = len(row)\n        for (j, cell) in enumerate(row):\n            if i <= mid:\n                diagonal = mid - row_len // 2 + j\n            else:\n                diagonal = mid - row_len // -2 + j + (i - mid)\n            diagonal_lines[diagonal].append(cell)\n    sorted_diagonal_lines = list(map(merge_sort, diagonal_lines))\n    sums = list(map(sum, sorted_diagonal_lines))\n    value = sum(sums)\n    return value"
    }
  ]
}