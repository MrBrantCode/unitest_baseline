{
  "task_id": "cf_58207",
  "entry_point": "longest_diagonal",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = 1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 1\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = -1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = -1\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_len = 0",
      "mutated_line": "max_len = 1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 1\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) or y < len(matrix[0]) or z < len(matrix[0][0]):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) or y < len(matrix[0]) or z < len(matrix[0][0]):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "x += 1",
      "mutated_line": "x -= 1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x -= 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "y += 1",
      "mutated_line": "y -= 1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y -= 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "z += 1",
      "mutated_line": "z -= 1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z -= 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if product == target and len(diagonal) > max_len:",
      "mutated_line": "if product == target or len(diagonal) > max_len:",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target or len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x <= len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x <= len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x >= len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x >= len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x != len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x != len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y <= len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y <= len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y >= len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y >= len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y != len(matrix[0]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y != len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z <= len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z <= len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z >= len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z >= len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z != len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z != len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x += 1",
      "mutated_line": "x += 2",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 2\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 0\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 0\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x += 1",
      "mutated_line": "x += -1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += -1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "y += 1",
      "mutated_line": "y += 2",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 2\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "y += 1",
      "mutated_line": "y += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 0\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "y += 1",
      "mutated_line": "y += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 0\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "y += 1",
      "mutated_line": "y += -1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += -1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "z += 1",
      "mutated_line": "z += 2",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 2\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 0\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "z += 1",
      "mutated_line": "z += 0",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 0\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "z += 1",
      "mutated_line": "z += -1",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += -1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if product == target and len(diagonal) > max_len:",
      "mutated_line": "if product != target and len(diagonal) > max_len:",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product != target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if product == target and len(diagonal) > max_len:",
      "mutated_line": "if product == target and len(diagonal) >= max_len:",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) >= max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if product == target and len(diagonal) > max_len:",
      "mutated_line": "if product == target and len(diagonal) <= max_len:",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) <= max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if product == target and len(diagonal) > max_len:",
      "mutated_line": "if product == target and len(diagonal) != max_len:",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) != max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] != target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] != target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[1]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[1]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[-1]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[-1]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[1]) and (z < len(matrix[0][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[1]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][1])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][1])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][-1])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][-1])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][1])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][1])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[1][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[1][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[-1][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[-1][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while x < len(matrix) and y < len(matrix[0]) and z < len(matrix[0][0]):",
      "mutated_line": "while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[1][0])):",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[1][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[-1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[-1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[1])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][1])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][1])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][-1])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][-1])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][1])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][1])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[1][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[1][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[-1][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[-1][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[0][0])) if matrix[i][j][k] == target])",
      "mutated_line": "queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[1][0])) if matrix[i][j][k] == target])",
      "code": "from collections import deque\nimport numpy as np\n\ndef longest_diagonal(cube, target):\n    matrix = np.array(cube)\n    queue = deque([(i, j, k) for i in range(len(matrix)) for j in range(len(matrix[0])) for k in range(len(matrix[1][0])) if matrix[i][j][k] == target])\n    max_len = 0\n    max_diagonal = []\n    max_coordinates = []\n    while queue:\n        (x, y, z) = queue.popleft()\n        (diagonal, coordinates) = get_diagonal(matrix, x, y, z)\n        product = np.prod(diagonal)\n        if product == target and len(diagonal) > max_len:\n            max_len = len(diagonal)\n            max_diagonal = diagonal\n            max_coordinates = coordinates\n    return (max_diagonal, max_coordinates)\n\ndef get_diagonal(matrix, x, y, z):\n    diagonal = []\n    coordinates = []\n    while x < len(matrix) and y < len(matrix[0]) and (z < len(matrix[0][0])):\n        diagonal.append(matrix[x][y][z])\n        coordinates.append((x, y, z))\n        x += 1\n        y += 1\n        z += 1\n    return (diagonal, coordinates)"
    }
  ]
}