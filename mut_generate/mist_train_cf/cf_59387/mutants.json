{
  "task_id": "cf_59387",
  "entry_point": "quantum_entanglement_particles",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i - 1, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i - 1, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i * 1, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i * 1, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if abs(particles[i].position - particles[j].position) <= separation_distance:",
      "mutated_line": "if abs(particles[i].position - particles[j].position) < separation_distance:",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 1, len(particles)):\n            if abs(particles[i].position - particles[j].position) < separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if abs(particles[i].position - particles[j].position) <= separation_distance:",
      "mutated_line": "if abs(particles[i].position - particles[j].position) > separation_distance:",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 1, len(particles)):\n            if abs(particles[i].position - particles[j].position) > separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if abs(particles[i].position - particles[j].position) <= separation_distance:",
      "mutated_line": "if abs(particles[i].position - particles[j].position) == separation_distance:",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 1, len(particles)):\n            if abs(particles[i].position - particles[j].position) == separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i + 2, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 2, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i + 0, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 0, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i + 0, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 0, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(i + 1, len(particles)):",
      "mutated_line": "for j in range(i + -1, len(particles)):",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + -1, len(particles)):\n            if abs(particles[i].position - particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if abs(particles[i].position - particles[j].position) <= separation_distance:",
      "mutated_line": "if abs(particles[i].position + particles[j].position) <= separation_distance:",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 1, len(particles)):\n            if abs(particles[i].position + particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if abs(particles[i].position - particles[j].position) <= separation_distance:",
      "mutated_line": "if abs(particles[i].position * particles[j].position) <= separation_distance:",
      "code": "class Particle:\n\n    def __init__(self, position, properties):\n        self.position = position\n        self.properties = properties\n        self.entangled_particle = None\n\n    def entangle(self, other_particle):\n        self.entangled_particle = other_particle\n        other_particle.entangled_particle = self\n\n    def update_properties(self, new_properties):\n        self.properties = new_properties\n        if self.entangled_particle:\n            self.entangled_particle.properties = new_properties\n\ndef quantum_entanglement_particles(particles, separation_distance):\n    entangled_particles = []\n    for i in range(len(particles)):\n        for j in range(i + 1, len(particles)):\n            if abs(particles[i].position * particles[j].position) <= separation_distance:\n                particles[i].entangle(particles[j])\n                entangled_particles.append((particles[i], particles[j]))\n    return entangled_particles"
    }
  ]
}