{
  "task_id": "cf_35720",
  "entry_point": "merge_sort",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if right > left:",
      "mutated_line": "if right >= left:",
      "code": "def merge_sort(arr, left, right):\n    if right >= left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if right > left:",
      "mutated_line": "if right <= left:",
      "code": "def merge_sort(arr, left, right):\n    if right <= left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if right > left:",
      "mutated_line": "if right != left:",
      "code": "def merge_sort(arr, left, right):\n    if right != left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "inversions += merge_sort(arr, left, mid)",
      "mutated_line": "inversions -= merge_sort(arr, left, mid)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions -= merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions -= merge_sort(arr, mid + 1, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions -= merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "inversions += merge(arr, left, mid, right)",
      "mutated_line": "inversions -= merge(arr, left, mid, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions -= merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 1\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return -1\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 1\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid - left - 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left - 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = (mid - left) * 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = (mid - left) * 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n2 = right - mid",
      "mutated_line": "n2 = right + mid",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right + mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n2 = right - mid",
      "mutated_line": "n2 = right * mid",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right * mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 1\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = -1\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 1\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 1\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = -1\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = j = 0",
      "mutated_line": "i = j = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 1\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i < n1 or j < n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 or j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k -= 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i < n1:",
      "mutated_line": "while i <= n1:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i <= n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i < n1:",
      "mutated_line": "while i >= n1:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i >= n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i < n1:",
      "mutated_line": "while i != n1:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i != n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i -= 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k -= 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while j < n2:",
      "mutated_line": "while j <= n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j <= n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while j < n2:",
      "mutated_line": "while j >= n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j >= n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while j < n2:",
      "mutated_line": "while j != n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j != n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j -= 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k -= 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left - (right - left) // 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left - (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left * ((right - left) // 2)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left * ((right - left) // 2)\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 1\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = -1\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "inversions = 0",
      "mutated_line": "inversions = 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 1\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid + left + 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid + left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid * left + 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid * left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid - left + 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 2\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid - left + 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 0\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid - left + 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 0\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "n1 = mid - left + 1",
      "mutated_line": "n1 = mid - left + -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + -1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i <= n1 and j < n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i <= n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i >= n1 and j < n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i >= n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i != n1 and j < n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i != n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i < n1 and j <= n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j <= n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i < n1 and j >= n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j >= n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while i < n1 and j < n2:",
      "mutated_line": "while i < n1 and j != n2:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j != n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if L[i] <= R[j]:",
      "mutated_line": "if L[i] < R[j]:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] < R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if L[i] <= R[j]:",
      "mutated_line": "if L[i] > R[j]:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] > R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if L[i] <= R[j]:",
      "mutated_line": "if L[i] == R[j]:",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] == R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i -= 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j -= 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "inversions += n1 - i  # Count inversions",
      "mutated_line": "inversions -= n1 - i",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions -= n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 2\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 0\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 0\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += -1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 2\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 0\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 0\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += -1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 2\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 0\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 0\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += -1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 2\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 0\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 0\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += -1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 2\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 0\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 0\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += -1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) / 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) / 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) * 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) * 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid - 1, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid - 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid * 1, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid * 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "L = [arr[left + i] for i in range(n1)]",
      "mutated_line": "L = [arr[left - i] for i in range(n1)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left - i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "L = [arr[left + i] for i in range(n1)]",
      "mutated_line": "L = [arr[left * i] for i in range(n1)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left * i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid + 1 - j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 - j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[(mid + 1) * j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[(mid + 1) * j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 2\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 0\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 0\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += -1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 2\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 0\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 0\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += -1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "inversions += n1 - i  # Count inversions",
      "mutated_line": "inversions += n1 + i",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 + i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "inversions += n1 - i  # Count inversions",
      "mutated_line": "inversions += n1 * i",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 * i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right + left) // 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right + left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + right * left // 2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + right * left // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 3",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 3\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 1\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 0",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 0\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // 1",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 1\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mid = left + (right - left) // 2",
      "mutated_line": "mid = left + (right - left) // -2",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // -2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid + 2, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 2, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid + 0, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 0, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid + 0, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 0, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "inversions += merge_sort(arr, mid + 1, right)",
      "mutated_line": "inversions += merge_sort(arr, mid + -1, right)",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + -1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid - 1 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid - 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid * 1 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid * 1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid + 2 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 2 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid + 0 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 0 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid + 0 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + 0 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "R = [arr[mid + 1 + j] for j in range(n2)]",
      "mutated_line": "R = [arr[mid + -1 + j] for j in range(n2)]",
      "code": "def merge_sort(arr, left, right):\n    if right > left:\n        mid = left + (right - left) // 2\n        inversions = 0\n        inversions += merge_sort(arr, left, mid)\n        inversions += merge_sort(arr, mid + 1, right)\n        inversions += merge(arr, left, mid, right)\n        return inversions\n    return 0\n\ndef merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L = [arr[left + i] for i in range(n1)]\n    R = [arr[mid + -1 + j] for j in range(n2)]\n    inversions = 0\n    i = j = 0\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n            inversions += n1 - i\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    return inversions"
    }
  ]
}