{
  "task_id": "cf_77483",
  "entry_point": "slidingPuzzle",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if grid == final: return 0",
      "mutated_line": "if grid != final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid != final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if grid == final: return 0",
      "mutated_line": "if grid == final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 1\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if grid == final: return 0",
      "mutated_line": "if grid == final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return -1\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if grid == final: return 0",
      "mutated_line": "if grid == final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 1\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): 1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 1}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): -1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): -1}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distances = {state(grid): 0}",
      "mutated_line": "distances = {state(grid): 1}",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 1}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[2, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[2, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[0, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[0, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[0, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[0, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[-1, 2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[-1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 3], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 3], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 1], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 1], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 0], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 0], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 1], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 1], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, -2], [3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, -2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [4, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [4, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [2, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [2, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [0, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [0, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [1, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [1, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [-3, 0]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [-3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 1]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, -1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, -1]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "final = [[1,2],[3,0]]",
      "mutated_line": "final = [[1, 2], [3, 1]]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 1]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (1, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (-1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (-1, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (1, 0)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (1, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 1)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, -1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, -1)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x, y = 0, 0",
      "mutated_line": "(x, y) = (0, 1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 1)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(3):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(3):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(1):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(0):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(0):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(1):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for r in range(2):",
      "mutated_line": "for r in range(-2):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(-2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 or 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 or 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(grid, 0)]",
      "mutated_line": "queue = [(grid, 1)]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 1)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(grid, 0)]",
      "mutated_line": "queue = [(grid, -1)]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, -1)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue = [(grid, 0)]",
      "mutated_line": "queue = [(grid, 1)]",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 1)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(-1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(-1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current, step = queue.pop(0)",
      "mutated_line": "(current, step) = queue.pop(1)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(1)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if newState not in distances:",
      "mutated_line": "if newState in distances:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(3):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(3):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(1):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(0):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(0):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(1):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(1):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in range(2):",
      "mutated_line": "for c in range(-2):",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(-2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if g[r][c] == 0:",
      "mutated_line": "if g[r][c] != 0:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] != 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 0), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(+1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, -1), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 1), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (1, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (-1, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (1, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 2), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 2), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 0), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 0), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, -1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, -1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (2, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (2, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (0, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (0, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (0, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (0, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (-1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 1), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, -1), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 1), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (-1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (-1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (1, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (1, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, +1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, +1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x - dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x * dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y - dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y * dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 < nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 < nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 > nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 > nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 == nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 == nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 < ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 < ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 > ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 > ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 == ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 == ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step - 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step - 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step * 1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step * 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if nextGrid == final:",
      "mutated_line": "if nextGrid != final:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid != final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if g[r][c] == 0:",
      "mutated_line": "if g[r][c] == 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if g[r][c] == 0:",
      "mutated_line": "if g[r][c] == -1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == -1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if g[r][c] == 0:",
      "mutated_line": "if g[r][c] == 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 1:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 0), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-2, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-0, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-0, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 0), (0, 1), (1, 0), (0, -1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(--1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -2)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -2)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -0)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -0)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -0)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, --1)]:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, --1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if -1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if -1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 1 <= nx < 2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 1 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 3 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 3 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 1 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 1 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 0 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 0 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 1 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 1 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < -2 and 0 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < -2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 1 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and -1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and -1 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 1 <= ny < 2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 1 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 3:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 3:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 1:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 0:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 0:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < 1:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 1:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 0 <= nx < 2 and 0 <= ny < 2:",
      "mutated_line": "if 0 <= nx < 2 and 0 <= ny < -2:",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < -2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 2",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 2\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 0\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + 0",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 0\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "distances[newState] = step + 1",
      "mutated_line": "distances[newState] = step + -1",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + -1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step - 1))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step - 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step * 1))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step * 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step + 2))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step + 0))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step + 0))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "queue.append((nextGrid, step + 1))",
      "mutated_line": "queue.append((nextGrid, step + -1))",
      "code": "def slidingPuzzle(grid):\n    final = [[1, 2], [3, 0]]\n    if grid == final:\n        return 0\n\n    def state(g):\n        return str(g)\n\n    def adjacents(g):\n        (x, y) = (0, 0)\n        for r in range(2):\n            for c in range(2):\n                if g[r][c] == 0:\n                    (x, y) = (r, c)\n        for (dx, dy) in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < 2 and 0 <= ny < 2:\n                newGrid = [lst[:] for lst in g]\n                (newGrid[x][y], newGrid[nx][ny]) = (newGrid[nx][ny], newGrid[x][y])\n                yield newGrid\n    distances = {state(grid): 0}\n    queue = [(grid, 0)]\n    while queue:\n        (current, step) = queue.pop(0)\n        for nextGrid in adjacents(current):\n            newState = state(nextGrid)\n            if newState not in distances:\n                distances[newState] = step + 1\n                if nextGrid == final:\n                    return distances[state(final)]\n                queue.append((nextGrid, step + -1))\n    return -1"
    }
  ]
}