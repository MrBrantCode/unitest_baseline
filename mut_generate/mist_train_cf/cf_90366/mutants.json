{
  "task_id": "cf_90366",
  "entry_point": "segmented_sieve",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) - 1",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) - 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) * 1",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) * 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [True] * limit",
      "mutated_line": "is_prime = [True] / limit",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] / limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [True] * limit",
      "mutated_line": "is_prime = [True] + limit",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] + limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "is_prime = [True] * limit",
      "mutated_line": "is_prime = [True] ** limit",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] ** limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) + 2",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 2\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) + 0",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 0\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) + 0",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 0\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "limit = int(math.sqrt(upper)) + 1",
      "mutated_line": "limit = int(math.sqrt(upper)) + -1",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + -1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(3, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(3, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(1, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(0, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(0, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(1, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(-2, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(-2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(3, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(3, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(1, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(0, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(0, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(1, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, limit):",
      "mutated_line": "for i in range(-2, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(-2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper - 1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper - 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper * 1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper * 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] / (high - low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] / (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] + (high - low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] + (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] ** (high - low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] ** (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "is_prime = [True] * limit",
      "mutated_line": "is_prime = [False] * limit",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [False] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper + 2, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 2, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper + 0, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 0, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper + 0, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 0, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for low in range(lower, upper + 1, limit):",
      "mutated_line": "for low in range(lower, upper + -1, limit):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + -1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low + limit + 1, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit + 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min((low + limit) * 1, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min((low + limit) * 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high - low - 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low - 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * ((high - low) * 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * ((high - low) * 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "start = math.ceil(low / prime) * prime",
      "mutated_line": "start = math.ceil(low / prime) / prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) / prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "start = math.ceil(low / prime) * prime",
      "mutated_line": "start = math.ceil(low / prime) + prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) + prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "start = math.ceil(low / prime) * prime",
      "mutated_line": "start = math.ceil(low / prime) ** prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) ** prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if start == prime:",
      "mutated_line": "if start != prime:",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start != prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high - 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high * 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] or i >= lower or i > 1:",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] or i >= lower or i > 1:\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(i * i, limit, i):",
      "mutated_line": "for j in range(i / i, limit, i):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i / i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(i * i, limit, i):",
      "mutated_line": "for j in range(i + i, limit, i):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i + i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(i * i, limit, i):",
      "mutated_line": "for j in range(i ** i, limit, i):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i ** i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "is_prime[j] = False",
      "mutated_line": "is_prime[j] = True",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = True\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low - limit - 1, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low - limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low * limit - 1, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low * limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low + limit - 2, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 2, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low + limit - 0, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 0, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low + limit - 0, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 0, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = min(low + limit - 1, upper)",
      "mutated_line": "high = min(low + limit - -1, upper)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - -1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [False] * (high - low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [False] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high + low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high + low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high * low + 1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high * low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high - low + 2)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 2)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high - low + 0)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 0)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high - low + 0)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 0)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "is_segment_prime = [True] * (high - low + 1)",
      "mutated_line": "is_segment_prime = [True] * (high - low + -1)",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + -1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "start = prime * prime",
      "mutated_line": "start = prime / prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime / prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "start = prime * prime",
      "mutated_line": "start = prime + prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime + prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "start = prime * prime",
      "mutated_line": "start = prime ** prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime ** prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high - 1, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high - 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high * 1, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high * 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "is_segment_prime[j - low] = False",
      "mutated_line": "is_segment_prime[j - low] = True",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = True\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 2):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 0):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 0):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(low, high + 1):",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + -1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i > lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i > lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i < lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i < lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i == lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i == lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i >= 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i >= 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i <= 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i <= 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i != 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i != 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "start = math.ceil(low / prime) * prime",
      "mutated_line": "start = math.ceil(low * prime) * prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low * prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "start = math.ceil(low / prime) * prime",
      "mutated_line": "start = math.ceil(low // prime) * prime",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low // prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high + 2, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 2, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high + 0, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 0, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high + 0, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 0, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(start, high + 1, prime):",
      "mutated_line": "for j in range(start, high + -1, prime):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + -1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "is_segment_prime[j - low] = False",
      "mutated_line": "is_segment_prime[j + low] = False",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j + low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "is_segment_prime[j - low] = False",
      "mutated_line": "is_segment_prime[j * low] = False",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j * low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i + low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i + low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i * low] and i >= lower and (i > 1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i * low] and i >= lower and (i > 1):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 2):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 2):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 0):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 0):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > 0):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > 0):\n                segmented_primes.append(i)\n    return segmented_primes"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if is_segment_prime[i - low] and i >= lower and i > 1:",
      "mutated_line": "if is_segment_prime[i - low] and i >= lower and (i > -1):",
      "code": "import math\n\ndef segmented_sieve(lower, upper):\n    limit = int(math.sqrt(upper)) + 1\n    is_prime = [True] * limit\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, limit, i):\n                is_prime[j] = False\n    primes = []\n    for i in range(2, limit):\n        if is_prime[i]:\n            primes.append(i)\n    segmented_primes = []\n    for low in range(lower, upper + 1, limit):\n        high = min(low + limit - 1, upper)\n        is_segment_prime = [True] * (high - low + 1)\n        for prime in primes:\n            start = math.ceil(low / prime) * prime\n            if start == prime:\n                start = prime * prime\n            for j in range(start, high + 1, prime):\n                is_segment_prime[j - low] = False\n        for i in range(low, high + 1):\n            if is_segment_prime[i - low] and i >= lower and (i > -1):\n                segmented_primes.append(i)\n    return segmented_primes"
    }
  ]
}