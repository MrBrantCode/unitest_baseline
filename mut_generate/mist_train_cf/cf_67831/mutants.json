{
  "task_id": "cf_67831",
  "entry_point": "travelling_salesman_problem",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] / N for _ in range(1 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] / N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] + N for _ in range(1 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] + N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] ** N for _ in range(1 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] ** N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(2, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(2, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(0, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(0, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(-1, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(-1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(3, N + 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(3, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(1, N + 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(1, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(0, N + 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(0, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(1, N + 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(1, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(-2, N + 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(-2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N - 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N - 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N * 1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N * 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "min_distance = float('inf')",
      "mutated_line": "min_distance = float('')",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(2, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(2, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(0, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(0, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(-1, N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(-1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N + 2):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 2):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N + 0):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 0):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N + 0):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 0):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for subset_size in range(2, N + 1):",
      "mutated_line": "for subset_size in range(2, N + -1):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + -1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if bin(subset).count('1') == subset_size:",
      "mutated_line": "if bin(subset).count('1') != subset_size:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') != subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] - dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] - dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] * dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] * dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[1 << j][j] = dist[1][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[1][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[1 << j][j] = dist[-1][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[-1][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[1 << j][j] = dist[1][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[1][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for subset in range(1 << N):",
      "mutated_line": "for subset in range(2 << N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(2 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for subset in range(1 << N):",
      "mutated_line": "for subset in range(0 << N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(0 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for subset in range(1 << N):",
      "mutated_line": "for subset in range(0 << N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(0 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for subset in range(1 << N):",
      "mutated_line": "for subset in range(-1 << N):",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(-1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('')] * N for _ in range(1 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] * N for _ in range(2 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(2 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] * N for _ in range(0 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(0 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] * N for _ in range(0 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(0 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp = [[float('inf')] * N for _ in range(1 << N)]",
      "mutated_line": "dp = [[float('inf')] * N for _ in range(-1 << N)]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(-1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[2 << j][j] = dist[0][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[2 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[0 << j][j] = dist[0][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[0 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[0 << j][j] = dist[0][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[0 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[1 << j][j] = dist[0][j]",
      "mutated_line": "dp[-1 << j][j] = dist[0][j]",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[-1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if bin(subset).count('1') == subset_size:",
      "mutated_line": "if bin(subset).count('') == subset_size:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j or subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j or subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][1])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][1])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][-1])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][-1])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][1])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][1])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset | 1 << j and subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset | 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j and subset == 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset == 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "prev_subset = subset ^ (1 << j)",
      "mutated_line": "prev_subset = subset | 1 << j",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset | 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) + 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) + 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) * 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) * 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j or prev_subset & 1 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j or prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 2][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 2][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 0][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 0][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - 0][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 0][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(1 << N) - -1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - -1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 2 << j and subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 2 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 0 << j and subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 0 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 0 << j and subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 0 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & -1 << j and subset != 1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & -1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j and subset != 2 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 2 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j and subset != 0 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 0 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j and subset != 0 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 0 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if (subset & (1 << j)) and subset != (1 << j):",
      "mutated_line": "if subset & 1 << j and subset != -1 << j:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != -1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prev_subset = subset ^ (1 << j)",
      "mutated_line": "prev_subset = subset ^ 2 << j",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 2 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prev_subset = subset ^ (1 << j)",
      "mutated_line": "prev_subset = subset ^ 0 << j",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 0 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prev_subset = subset ^ (1 << j)",
      "mutated_line": "prev_subset = subset ^ 0 << j",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 0 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prev_subset = subset ^ (1 << j)",
      "mutated_line": "prev_subset = subset ^ -1 << j",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ -1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k == j and prev_subset & 1 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k == j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j and prev_subset | 1 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset | 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(2 << N) - 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(2 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(0 << N) - 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(0 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(0 << N) - 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(0 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])",
      "mutated_line": "min_distance = min(min_distance, dp[(-1 << N) - 1][j] + dist[j][0])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(-1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])",
      "mutated_line": "dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] - dist[k][j])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] - dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])",
      "mutated_line": "dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] * dist[k][j])",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] * dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j and prev_subset & 2 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 2 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j and prev_subset & 0 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 0 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j and prev_subset & 0 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & 0 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k != j and (prev_subset & (1 << k)):",
      "mutated_line": "if k != j and prev_subset & -1 << k:",
      "code": "def travelling_salesman_problem(dist):\n    \"\"\"\n    Solves the Travelling Salesman Problem using memoization and dynamic programming.\n    \n    Args:\n        dist (list of lists): A 2D list where dist[i][j] is the distance between city i and city j.\n    \n    Returns:\n        The shortest possible route that visits each city exactly once and returns to the original city.\n    \"\"\"\n    N = len(dist)\n    dp = [[float('inf')] * N for _ in range(1 << N)]\n    for j in range(1, N):\n        dp[1 << j][j] = dist[0][j]\n    for subset_size in range(2, N + 1):\n        for subset in range(1 << N):\n            if bin(subset).count('1') == subset_size:\n                for j in range(N):\n                    if subset & 1 << j and subset != 1 << j:\n                        prev_subset = subset ^ 1 << j\n                        for k in range(N):\n                            if k != j and prev_subset & -1 << k:\n                                dp[subset][j] = min(dp[subset][j], dp[prev_subset][k] + dist[k][j])\n    min_distance = float('inf')\n    for j in range(1, N):\n        min_distance = min(min_distance, dp[(1 << N) - 1][j] + dist[j][0])\n    return min_distance"
    }
  ]
}