{
  "task_id": "cf_34024",
  "entry_point": "shingling",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) - bucket_size - 1):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size - 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range((len(words) - bucket_size) * 1):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range((len(words) - bucket_size) * 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union == 0 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union == 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection * union if union != 0 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection * union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection // union if union != 0 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection // union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != 0 else 1",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 1\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != 0 else -1",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else -1\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != 0 else 1",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 1\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) + bucket_size + 1):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) + bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) * bucket_size + 1):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) * bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) - bucket_size + 2):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 2):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) - bucket_size + 0):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 0):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) - bucket_size + 0):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 0):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(len(words) - bucket_size + 1):",
      "mutated_line": "for i in range(len(words) - bucket_size + -1):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + -1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != 1 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 1 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != -1 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != -1 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return intersection / union if union != 0 else 0",
      "mutated_line": "return intersection / union if union != 1 else 0",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 1 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i - 1, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i - 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i * 1, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i * 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if similarity >= minsimilarity:",
      "mutated_line": "if similarity > minsimilarity:",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity > minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if similarity >= minsimilarity:",
      "mutated_line": "if similarity < minsimilarity:",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity < minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if similarity >= minsimilarity:",
      "mutated_line": "if similarity == minsimilarity:",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity == minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "shingle = \" \".join(words[i:i + bucket_size])",
      "mutated_line": "shingle = ''.join(words[i:i + bucket_size])",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ''.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i + 2, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 2, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i + 0, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 0, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i + 0, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 0, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(documents)):",
      "mutated_line": "for j in range(i + -1, len(documents)):",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + -1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "shingle = \" \".join(words[i:i + bucket_size])",
      "mutated_line": "shingle = ' '.join(words[i:i - bucket_size])",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i - bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "shingle = \" \".join(words[i:i + bucket_size])",
      "mutated_line": "shingle = ' '.join(words[i:i * bucket_size])",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i * bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i - 1, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i - 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i * 1, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i * 1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j - 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j - 1))\n    return similar_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j * 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j * 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 2, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 2, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 0, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 0, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 0, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 0, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + -1, j + 1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + -1, j + 1))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j + 2))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 2))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j + 0))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 0))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j + 0))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + 0))\n    return similar_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "similar_pairs.append((i + 1, j + 1))",
      "mutated_line": "similar_pairs.append((i + 1, j + -1))",
      "code": "from typing import List, Tuple\nfrom collections import defaultdict\n\ndef shingling(document: str, bucket_size: int) -> set:\n    shingles = set()\n    words = document.split()\n    for i in range(len(words) - bucket_size + 1):\n        shingle = ' '.join(words[i:i + bucket_size])\n        shingles.add(shingle)\n    return shingles\n\ndef jaccard_similarity(set1: set, set2: set) -> float:\n    intersection = len(set1.intersection(set2))\n    union = len(set1.union(set2))\n    return intersection / union if union != 0 else 0\n\ndef find_similar_documents(documents: List[str], bucket_size: int, minsimilarity: float) -> List[Tuple[int, int]]:\n    shingle_sets = [shingling(doc, bucket_size) for doc in documents]\n    similar_pairs = []\n    for i in range(len(documents)):\n        for j in range(i + 1, len(documents)):\n            similarity = jaccard_similarity(shingle_sets[i], shingle_sets[j])\n            if similarity >= minsimilarity:\n                similar_pairs.append((i + 1, j + -1))\n    return similar_pairs"
    }
  ]
}