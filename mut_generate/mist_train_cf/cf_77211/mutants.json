{
  "task_id": "cf_77211",
  "entry_point": "url_generator",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "url = f\"{protocol}://{subdomain}.{domain}/{path}?{encoded_query}\"",
      "mutated_line": "url = f'{protocol}{subdomain}.{domain}/{path}?{encoded_query}'",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "url = f\"{protocol}://{subdomain}.{domain}/{path}?{encoded_query}\"",
      "mutated_line": "url = f'{protocol}://{subdomain}{domain}/{path}?{encoded_query}'",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "url = f\"{protocol}://{subdomain}.{domain}/{path}?{encoded_query}\"",
      "mutated_line": "url = f'{protocol}://{subdomain}.{domain}{path}?{encoded_query}'",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "url = f\"{protocol}://{subdomain}.{domain}/{path}?{encoded_query}\"",
      "mutated_line": "url = f'{protocol}://{subdomain}.{domain}/{path}{encoded_query}'",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "r'^(?:http|ftp)s?://'",
      "mutated_line": "regex = re.compile('', re.IGNORECASE)",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return \"Invalid URL\"",
      "mutated_line": "return ''",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[0]).decode()\n        return base64_decoded_params\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "base64_decoded_params[key] = base64.b64decode(val[0]).decode()",
      "mutated_line": "base64_decoded_params[key] = base64.b64decode(val[1]).decode()",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[1]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "base64_decoded_params[key] = base64.b64decode(val[0]).decode()",
      "mutated_line": "base64_decoded_params[key] = base64.b64decode(val[-1]).decode()",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[-1]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "base64_decoded_params[key] = base64.b64decode(val[0]).decode()",
      "mutated_line": "base64_decoded_params[key] = base64.b64decode(val[1]).decode()",
      "code": "import urllib.parse\nimport re\nimport base64\n\ndef url_generator(protocol, subdomain, domain, path, param_dict):\n    \"\"\"\n    Generates an internet address utilizing the provided details and validates it against the official URL regex.\n    The function takes in a protocol, subdomain, domain, path, and a dictionary containing key/value pairs for each query parameter.\n    The function encodes each query parameter value using Base64.\n    \n    Args:\n        protocol (str): The protocol to use (e.g., http, https).\n        subdomain (str): The subdomain.\n        domain (str): The domain.\n        path (str): The path.\n        param_dict (dict): A dictionary containing key/value pairs for each query parameter.\n    \n    Returns:\n        str: The constructed URL.\n    \"\"\"\n    base64_encoded_params = {}\n    for (key, val) in param_dict.items():\n        base64_encoded_params[key] = base64.b64encode(val.encode()).decode()\n    encoded_query = urllib.parse.urlencode(base64_encoded_params)\n    url = f'{protocol}://{subdomain}.{domain}/{path}?{encoded_query}'\n    return url\n\ndef url_decoder(url):\n    \"\"\"\n    Takes a URL and returns the original parameters and their values after Base64 decryption.\n    \n    Args:\n        url (str): The URL to decode.\n    \n    Returns:\n        dict: A dictionary containing the original parameters and their values.\n    \"\"\"\n    base64_decoded_params = {}\n    regex = re.compile('^(?:http|ftp)s?://(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\\\.)+(?:[A-Z]{2,6}\\\\.?|[A-Z0-9-]{2,}\\\\.?)|localhost|\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3})(?::\\\\d+)?(?:/?|[/?]\\\\S+)$', re.IGNORECASE)\n    if re.match(regex, url):\n        query_string = urllib.parse.urlparse(url).query\n        query_dict = urllib.parse.parse_qs(query_string)\n        for (key, val) in query_dict.items():\n            base64_decoded_params[key] = base64.b64decode(val[1]).decode()\n        return base64_decoded_params\n    else:\n        return 'Invalid URL'"
    }
  ]
}