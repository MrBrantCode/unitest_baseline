{
  "task_id": "cf_28802",
  "entry_point": "simulate_projectile",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "g = 9.81  # m/s^2",
      "mutated_line": "g = 10.81",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 10.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "g = 9.81  # m/s^2",
      "mutated_line": "g = 8.81",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 8.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "g = 9.81  # m/s^2",
      "mutated_line": "g = 0",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 0\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "g = 9.81  # m/s^2",
      "mutated_line": "g = 1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 1\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "g = 9.81  # m/s^2",
      "mutated_line": "g = -9.81",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = -9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 1\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = -1\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 1\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 1\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 0",
      "mutated_line": "y = -1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = -1\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 1\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vx = v0 * math.cos(theta_rad)",
      "mutated_line": "vx = v0 / math.cos(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 / math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vx = v0 * math.cos(theta_rad)",
      "mutated_line": "vx = v0 + math.cos(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 + math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vx = v0 * math.cos(theta_rad)",
      "mutated_line": "vx = v0 ** math.cos(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 ** math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "vy = v0 * math.sin(theta_rad)",
      "mutated_line": "vy = v0 / math.sin(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 / math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "vy = v0 * math.sin(theta_rad)",
      "mutated_line": "vy = v0 + math.sin(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 + math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "vy = v0 * math.sin(theta_rad)",
      "mutated_line": "vy = v0 ** math.sin(theta_rad)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 ** math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time >= 0:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time >= 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time <= 0:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time <= 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time != 0:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time != 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "x += vx * dt",
      "mutated_line": "x -= vx * dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x -= vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "y += vy * dt",
      "mutated_line": "y -= vy * dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y -= vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "vx += ax * dt",
      "mutated_line": "vx -= ax * dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx -= ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "vy += ay * dt",
      "mutated_line": "vy -= ay * dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy -= ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "total_time -= dt",
      "mutated_line": "return (x_values, y_values)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time += dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time > 1:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 1:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time > -1:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > -1:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while total_time > 0:",
      "mutated_line": "while total_time > 1:",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 1:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = -k * v * vx * m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx * m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = -k * v * vx // m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx // m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g + k * v * vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g + k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g * (k * v * vy / m)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g * (k * v * vy / m)\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "x += vx * dt",
      "mutated_line": "x += vx / dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx / dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "x += vx * dt",
      "mutated_line": "x += vx + dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx + dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "x += vx * dt",
      "mutated_line": "x += vx ** dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx ** dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y += vy * dt",
      "mutated_line": "y += vy / dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy / dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y += vy * dt",
      "mutated_line": "y += vy + dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy + dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "y += vy * dt",
      "mutated_line": "y += vy ** dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy ** dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vx += ax * dt",
      "mutated_line": "vx += ax / dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax / dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vx += ax * dt",
      "mutated_line": "vx += ax + dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax + dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "vx += ax * dt",
      "mutated_line": "vx += ax ** dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax ** dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vy += ay * dt",
      "mutated_line": "vy += ay / dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay / dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vy += ay * dt",
      "mutated_line": "vy += ay + dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay + dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vy += ay * dt",
      "mutated_line": "vy += ay ** dt",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay ** dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 - vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 - vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 * vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 * vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = -k * v / vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v / vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = (-k * v + vx) / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = (-k * v + vx) / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = (-k * v) ** vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = (-k * v) ** vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = +g - k * v * vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = +g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - k * v * vy * m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy * m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - k * v * vy // m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy // m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx * 2 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx * 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx + 2 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx + 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy * 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy * 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + (vy + 2))",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + (vy + 2))\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = -k / v * vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k / v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = (-k + v) * vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = (-k + v) * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = (-k) ** v * vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = (-k) ** v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - k * v / vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v / vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - (k * v + vy) / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - (k * v + vy) / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - (k * v) ** vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - (k * v) ** vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 3 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 3 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 1 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 1 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 0 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 0 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 1 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 1 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** -2 + vy ** 2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** -2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy ** 3)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 3)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy ** 1)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 1)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy ** 0)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 0)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy ** 1)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 1)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v = math.sqrt(vx**2 + vy**2)",
      "mutated_line": "v = math.sqrt(vx ** 2 + vy ** -2)",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** -2)\n        ax = -k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "ax = -k * v * vx / m",
      "mutated_line": "ax = +k * v * vx / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = +k * v * vx / m\n        ay = -g - k * v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - k / v * vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k / v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - (k + v) * vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - (k + v) * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ay = -g - k * v * vy / m",
      "mutated_line": "ay = -g - k ** v * vy / m",
      "code": "import math\n\ndef simulate_projectile(m, v0, theta, k, dt, total_time):\n    g = 9.81\n    x_values = []\n    y_values = []\n    theta_rad = math.radians(theta)\n    x = 0\n    y = 0\n    vx = v0 * math.cos(theta_rad)\n    vy = v0 * math.sin(theta_rad)\n    while total_time > 0:\n        x_values.append(x)\n        y_values.append(y)\n        v = math.sqrt(vx ** 2 + vy ** 2)\n        ax = -k * v * vx / m\n        ay = -g - k ** v * vy / m\n        x += vx * dt\n        y += vy * dt\n        vx += ax * dt\n        vy += ay * dt\n        total_time -= dt\n    return (x_values, y_values)"
    }
  ]
}