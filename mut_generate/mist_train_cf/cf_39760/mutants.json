{
  "task_id": "cf_39760",
  "entry_point": "jouer",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "count -= grid[row][col]",
      "mutated_line": "count += grid[row][col]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count += grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = -1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[1])",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[1])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[-1])",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[-1])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cols = len(grid[0])",
      "mutated_line": "cols = len(grid[1])",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[1])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "count += grid[i][j]",
      "mutated_line": "count -= grid[i][j]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count -= grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[0] / cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] / cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[0] + cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] + cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[0] ** cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] ** cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(1, row - 1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(-1, row - 1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(-1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(1, row - 1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row + 1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row + 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row * 1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row * 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row - 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row - 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row * 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row * 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] != 1:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] != 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 2), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 2), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 0), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 0), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 0), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 0), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - -1), min(rows, row + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - -1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 3)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 3)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 1)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 1)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 0)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 0)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 1)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 1)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row-1), min(rows, row+2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + -2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + -2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(1, col - 1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(1, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(-1, col - 1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(-1, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(1, col - 1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(1, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col + 1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col + 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col * 1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col * 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col - 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col - 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col * 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col * 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[1] * cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[1] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[-1] * cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[-1] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "new_grid = [[0] * cols for _ in range(rows)]",
      "mutated_line": "new_grid = [[1] * cols for _ in range(rows)]",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[1] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 2:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 2:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 0:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 0:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == -1:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == -1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 and live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 and live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors != 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 2), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 2), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 0), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 0), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 0), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 0), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - -1), min(cols, col + 2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - -1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 3)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 3)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 1)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 1)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 0)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 0)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 1)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 1)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col-1), min(cols, col+2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + -2)):",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + -2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors <= 2 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors <= 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors >= 2 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors >= 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors != 2 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors != 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors >= 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors >= 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors <= 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors <= 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors != 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors != 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_grid[i][j] = 0",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 1\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_grid[i][j] = 0",
      "mutated_line": "new_grid[i][j] = -1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = -1\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "new_grid[i][j] = 0",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 1\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 2",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 2\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 0",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 0\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 0",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 0\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = -1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = -1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 4:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 2:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 0:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 1:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "new_grid[i][j] = 1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == -3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 2",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 2\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 0",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 0\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = 0",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 0\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "new_grid[i][j] = 1",
      "mutated_line": "new_grid[i][j] = -1",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = -1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 3 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 3 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 1 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 0 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 0 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 1 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < -2 or live_neighbors > 3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < -2 or live_neighbors > 3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 4:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 4:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 2:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 2:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 0:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 0:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 1:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 1:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > -3:",
      "code": "def jouer(grid, generations):\n    rows = len(grid)\n    cols = len(grid[0])\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += grid[i][j]\n        count -= grid[row][col]\n        return count\n\n    def next_generation():\n        new_grid = [[0] * cols for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if grid[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > -3:\n                        new_grid[i][j] = 0\n                    else:\n                        new_grid[i][j] = 1\n                elif live_neighbors == 3:\n                    new_grid[i][j] = 1\n        return new_grid\n    for _ in range(generations):\n        grid = next_generation()\n    return grid"
    }
  ]
}