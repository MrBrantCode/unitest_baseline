{
  "task_id": "cf_22042",
  "entry_point": "find_reachable_states",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [0]  # Initialize stack with the initial state",
      "mutated_line": "stack = [1]",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [1]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [0]  # Initialize stack with the initial state",
      "mutated_line": "stack = [-1]",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [-1]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [0]  # Initialize stack with the initial state",
      "mutated_line": "stack = [1]",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [1]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if state not in reachable_states:",
      "mutated_line": "if state in reachable_states:",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if state in reachable_states and state not in non_reachable_states:",
      "mutated_line": "if state in reachable_states or state not in non_reachable_states:",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states or state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "reachable_states = set([0])  # Initialize reachable_states with the initial state",
      "mutated_line": "reachable_states = set([1])",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([1])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "reachable_states = set([0])  # Initialize reachable_states with the initial state",
      "mutated_line": "reachable_states = set([-1])",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([-1])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "reachable_states = set([0])  # Initialize reachable_states with the initial state",
      "mutated_line": "reachable_states = set([1])",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([1])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if next_state not in reachable_states:",
      "mutated_line": "if next_state in reachable_states:",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if state in reachable_states and state not in non_reachable_states:",
      "mutated_line": "if state not in reachable_states and state not in non_reachable_states:",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states and state not in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if state in reachable_states and state not in non_reachable_states:",
      "mutated_line": "if state in reachable_states and state in non_reachable_states:",
      "code": "def find_reachable_states(N, M, transitions):\n    reachable_states = set([0])\n    stack = [0]\n    while stack:\n        state = stack.pop()\n        for symbol in range(M):\n            next_state = transitions[state][symbol]\n            if next_state not in reachable_states:\n                reachable_states.add(next_state)\n                stack.append(next_state)\n    non_reachable_states = set()\n    for state in range(N):\n        if state not in reachable_states:\n            non_reachable_states.add(state)\n    partially_reachable_states = set()\n    for state in range(N):\n        if state in reachable_states and state in non_reachable_states:\n            partially_reachable_states.add(state)\n    return (reachable_states, non_reachable_states, partially_reachable_states)"
    }
  ]
}