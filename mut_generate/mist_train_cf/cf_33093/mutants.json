{
  "task_id": "cf_33093",
  "entry_point": "aStar",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if current_node == goal:",
      "mutated_line": "if current_node != goal:",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node != goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if current_node in closed_set:",
      "mutated_line": "if current_node not in closed_set:",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node not in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "open_set = [(0, start, [])]  # (estimated_total_cost, current_node, path)",
      "mutated_line": "open_set = [(1, start, [])]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(1, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "open_set = [(0, start, [])]  # (estimated_total_cost, current_node, path)",
      "mutated_line": "open_set = [(-1, start, [])]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(-1, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "open_set = [(0, start, [])]  # (estimated_total_cost, current_node, path)",
      "mutated_line": "open_set = [(1, start, [])]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(1, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return path + [current_node]",
      "mutated_line": "return path - [current_node]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path - [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return path + [current_node]",
      "mutated_line": "return path * [current_node]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path * [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if neighbor in closed_set:",
      "mutated_line": "if neighbor not in closed_set:",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor not in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_path = path + [current_node]",
      "mutated_line": "new_path = path - [current_node]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path - [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "new_path = path + [current_node]",
      "mutated_line": "new_path = path * [current_node]",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path * [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)",
      "mutated_line": "estimated_cost_to_neighbor = len(new_path) + cost - heuristic_estimate(neighbor, goal)",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) + cost - heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)",
      "mutated_line": "estimated_cost_to_neighbor = (len(new_path) + cost) * heuristic_estimate(neighbor, goal)",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = (len(new_path) + cost) * heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)",
      "mutated_line": "estimated_cost_to_neighbor = len(new_path) - cost + heuristic_estimate(neighbor, goal)",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) - cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "estimated_cost_to_neighbor = len(new_path) + cost + heuristic_estimate(neighbor, goal)",
      "mutated_line": "estimated_cost_to_neighbor = len(new_path) * cost + heuristic_estimate(neighbor, goal)",
      "code": "import heapq\n\ndef aStar(graph, start, goal, heuristic_estimate):\n    open_set = [(0, start, [])]\n    closed_set = set()\n    while open_set:\n        (estimated_total_cost, current_node, path) = heapq.heappop(open_set)\n        if current_node == goal:\n            return path + [current_node]\n        if current_node in closed_set:\n            continue\n        closed_set.add(current_node)\n        for (neighbor, cost) in graph.get(current_node, []):\n            if neighbor in closed_set:\n                continue\n            new_path = path + [current_node]\n            estimated_cost_to_neighbor = len(new_path) * cost + heuristic_estimate(neighbor, goal)\n            heapq.heappush(open_set, (estimated_cost_to_neighbor, neighbor, new_path))\n    return None"
    }
  ]
}