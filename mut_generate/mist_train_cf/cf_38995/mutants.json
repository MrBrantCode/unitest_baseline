{
  "task_id": "cf_38995",
  "entry_point": "minPathSum",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distance = [[float('inf')] * n for _ in range(m)]",
      "mutated_line": "distance[0][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] / n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distance = [[float('inf')] * n for _ in range(m)]",
      "mutated_line": "distance[0][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] + n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distance = [[float('inf')] * n for _ in range(m)]",
      "mutated_line": "distance[0][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] ** n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][1] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][1] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][-1] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][-1] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][1] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][1] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[0][1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][1]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[0][-1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][-1]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[0][1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][1]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n + 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n * 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n * 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[1][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[1][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[-1][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[-1][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[1][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[1][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[1][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[1][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[-1][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[-1][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[0][0] = grid[0][0]  # Initialize the top-left cell",
      "mutated_line": "distance[0][0] = grid[1][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[1][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(2, 0), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(2, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(0, 0), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(0, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(0, 0), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(0, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(-1, 0), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(-1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 1), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 1), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, -1), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, -1), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 1), (0, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 1), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (1, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (1, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (-1, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (-1, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (1, 1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (1, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (0, 2)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 2)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (0, 0)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 0)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (0, 0)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 0)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "directions = [(1, 0), (0, 1)]  # Down and right movements",
      "mutated_line": "directions = [(1, 0), (0, -1)]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, -1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m + 1][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m + 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m * 1][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m * 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n - 2]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n - 0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n - 0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 1][n - -1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - -1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[1]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[-1]))",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[-1]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "(m, n) = (len(grid), len(grid[1]))",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[1]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m or 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m or 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 2][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 2][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 0][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - 0][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 0][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[m - 1][n - 1]  # Return the minimum path sum",
      "mutated_line": "return distance[m - -1][n - 1]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - -1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distance = [[float('inf')] * n for _ in range(m)]",
      "mutated_line": "distance[0][0] = grid[0][0]",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nr, nc = i + dr, j + dc",
      "mutated_line": "(nr, nc) = (i - dr, j + dc)",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i - dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nr, nc = i + dr, j + dc",
      "mutated_line": "(nr, nc) = (i * dr, j + dc)",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i * dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nr, nc = i + dr, j + dc",
      "mutated_line": "(nr, nc) = (i + dr, j - dc)",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j - dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nr, nc = i + dr, j + dc",
      "mutated_line": "(nr, nc) = (i + dr, j * dc)",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j * dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 < nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 < nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 > nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 > nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 == nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 == nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and 0 < nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 < nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and 0 > nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 > nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and 0 == nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 == nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 1 <= nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 1 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if -1 <= nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if -1 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 1 <= nr < m and 0 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 1 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and 1 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 1 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and -1 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and -1 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if 0 <= nr < m and 0 <= nc < n:",
      "mutated_line": "if 0 <= nr < m and 1 <= nc < n:",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 1 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])",
      "mutated_line": "distance[nr][nc] = min(distance[nr][nc], distance[i][j] - grid[nr][nc])",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] - grid[nr][nc])\n    return distance[m - 1][n - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "distance[nr][nc] = min(distance[nr][nc], distance[i][j] + grid[nr][nc])",
      "mutated_line": "distance[nr][nc] = min(distance[nr][nc], distance[i][j] * grid[nr][nc])",
      "code": "from typing import List\nimport heapq\n\ndef minPathSum(grid: List[List[int]]) -> int:\n    \"\"\"\n    Calculate the minimum path sum from the top-left cell to the bottom-right cell in a grid.\n    \n    Args:\n    grid (List[List[int]]): A 2D list of integers representing the cost to traverse each cell.\n    \n    Returns:\n    int: The minimum path sum as an integer.\n    \"\"\"\n    (m, n) = (len(grid), len(grid[0]))\n    distance = [[float('inf')] * n for _ in range(m)]\n    distance[0][0] = grid[0][0]\n    directions = [(1, 0), (0, 1)]\n    for i in range(m):\n        for j in range(n):\n            for (dr, dc) in directions:\n                (nr, nc) = (i + dr, j + dc)\n                if 0 <= nr < m and 0 <= nc < n:\n                    distance[nr][nc] = min(distance[nr][nc], distance[i][j] * grid[nr][nc])\n    return distance[m - 1][n - 1]"
    }
  ]
}