{
  "task_id": "cf_31444",
  "entry_point": "calculate_angles",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) > 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) > 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) < 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) < 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) == 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) == 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= -1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= -1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 1 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) * 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) * 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 3) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 3) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 1) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 1) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 0) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 0) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 1) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 1) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, -2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, -2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) - 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) - 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) * 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) * 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 3) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 3) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 1) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 1) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 0) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 0) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 1) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 1) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, -2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, -2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 361, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 361, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 359, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 359, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 0, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 0, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 1, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 1, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % -360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % -360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 361, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 361, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 359, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 359, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 0, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 0, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 1, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 1, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + -360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + -360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] + main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] * main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] + main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] * main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[2] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[0] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[-1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[2], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[0], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[-1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[-1] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[1] - main_point[0])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[-1])) + 360, 2) for point in list_of_points]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) + 360, 2) for point in list_of_points]",
      "mutated_line": "return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) + 360, 2) for point in list_of_points]",
      "code": "import math\n\ndef calculate_angles(list_of_points, main_point):\n    return [round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) % 360, 2) if math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[0])) >= 0 else round(math.degrees(math.atan2(point[1] - main_point[1], point[0] - main_point[1])) + 360, 2) for point in list_of_points]"
    }
  ]
}