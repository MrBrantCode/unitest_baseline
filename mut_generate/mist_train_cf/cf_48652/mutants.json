{
  "task_id": "cf_48652",
  "entry_point": "evaluate_rules",
  "mutant_count": 12,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if consequent in facts:",
      "mutated_line": "if consequent not in facts:",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent not in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return True\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return False\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return True\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]",
      "mutated_line": "applicable_rules = [rule for rule in rules if rule['consequent'] != consequent]",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] != consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return False\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if backward_chaining(rule['consequent'], facts, rules):",
      "mutated_line": "if backward_chaining(rule[''], facts, rules):",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule[''], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "true_consequents.append(rule['consequent'])",
      "mutated_line": "true_consequents.append(rule[''])",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule[''])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]",
      "mutated_line": "applicable_rules = [rule for rule in rules if rule[''] == consequent]",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule[''] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents'])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if all(backward_chaining(antecedent, facts, rules) for antecedent in rule['antecedents']):",
      "mutated_line": "if all((backward_chaining(antecedent, facts, rules) for antecedent in rule[''])):",
      "code": "def evaluate_rules(rules, facts):\n    \"\"\"\n    Evaluate a set of rules against a set of facts.\n\n    This is a basic implementation of a rule-based system using the Backward Chaining algorithm.\n\n    Args:\n        rules (list): A list of rules, where each rule is a dictionary with 'antecedents' and 'consequent' keys.\n        facts (list): A list of facts, where each fact is a string.\n\n    Returns:\n        list: A list of consequents that are true based on the given facts and rules.\n    \"\"\"\n\n    def backward_chaining(consequent, facts, rules):\n        \"\"\"\n        Apply the Backward Chaining algorithm to find the antecedents of a consequent.\n\n        Args:\n            consequent (str): The consequent to find antecedents for.\n            facts (list): A list of facts.\n            rules (list): A list of rules.\n\n        Returns:\n            bool: True if the consequent is true, False otherwise.\n        \"\"\"\n        if consequent in facts:\n            return True\n        applicable_rules = [rule for rule in rules if rule['consequent'] == consequent]\n        if not applicable_rules:\n            return False\n        for rule in applicable_rules:\n            if all((backward_chaining(antecedent, facts, rules) for antecedent in rule[''])):\n                return True\n        return False\n    true_consequents = []\n    for rule in rules:\n        if backward_chaining(rule['consequent'], facts, rules):\n            true_consequents.append(rule['consequent'])\n    return true_consequents"
    }
  ]
}