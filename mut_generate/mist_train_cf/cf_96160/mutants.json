{
  "task_id": "cf_96160",
  "entry_point": "evaluate_reverse_polish_notation",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[-1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return stack[0]",
      "mutated_line": "return stack[1]",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[1]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "elif token in ['+', '-', '*', '/']:",
      "mutated_line": "elif token not in ['+', '-', '*', '/']:",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token not in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if token == '+':",
      "mutated_line": "if token != '+':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token != '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if token.lstrip('-').isdigit():",
      "mutated_line": "if token.lstrip('').isdigit():",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif token in ['+', '-', '*', '/']:",
      "mutated_line": "elif token in ['', '-', '*', '/']:",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif token in ['+', '-', '*', '/']:",
      "mutated_line": "elif token in ['+', '', '*', '/']:",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif token in ['+', '-', '*', '/']:",
      "mutated_line": "elif token in ['+', '-', '', '/']:",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "elif token in ['+', '-', '*', '/']:",
      "mutated_line": "elif token in ['+', '-', '*', '']:",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if token == '+':",
      "mutated_line": "if token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token != '-':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token != '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "stack.append(operand1 + operand2)",
      "mutated_line": "stack.append(operand1 - operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 - operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "stack.append(operand1 + operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 * operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif token == '-':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token != '*':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token != '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "stack.append(operand1 - operand2)",
      "mutated_line": "stack.append(operand1 + operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 + operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "stack.append(operand1 - operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 * operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif token == '*':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif token == '/':",
      "mutated_line": "elif token != '/':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token != '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 / operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 / operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 + operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 + operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "stack.append(operand1 * operand2)",
      "mutated_line": "stack.append(operand1 ** operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 ** operand2)\n            elif token == '/':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif token == '/':",
      "mutated_line": "elif token == '':",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '':\n                stack.append(operand1 / operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "stack.append(operand1 / operand2)",
      "mutated_line": "stack.append(operand1 * operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 * operand2)\n    return stack[0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "stack.append(operand1 / operand2)",
      "mutated_line": "stack.append(operand1 // operand2)",
      "code": "def evaluate_reverse_polish_notation(expression):\n    stack = []\n    for token in expression:\n        if token.lstrip('-').isdigit():\n            stack.append(int(token))\n        elif token in ['+', '-', '*', '/']:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                stack.append(operand1 // operand2)\n    return stack[0]"
    }
  ]
}