{
  "task_id": "cf_76742",
  "entry_point": "find_depth",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "depth = 0",
      "mutated_line": "depth = 1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 1\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "depth = 0",
      "mutated_line": "depth = -1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = -1\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "depth = 0",
      "mutated_line": "depth = 1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 1\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "depth += 1",
      "mutated_line": "depth -= 1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth -= 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 1\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return -1\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 1\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth += 1",
      "mutated_line": "depth += 2",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 2\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth += 1",
      "mutated_line": "depth += 0",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 0\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth += 1",
      "mutated_line": "depth += 0",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 0\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "depth += 1",
      "mutated_line": "depth += -1",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += -1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while False:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if val is None:",
      "mutated_line": "if val is not None:",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is not None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 1 <= len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 <= len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 1 >= len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 >= len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 1 != len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 != len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 2 <= len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 <= len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 2 >= len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 >= len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 2 != len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 != len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) - 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) - 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) * 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) * 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) - 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) - 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) * 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) * 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 / nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 / nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 + nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 + nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 ** nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 ** nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 0 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 0 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 0 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 0 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + -1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + -1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 / nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 / nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 + nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 + nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 ** nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 ** nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 3 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 3 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 0 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 0 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 2 * nums.index(val) + -2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + -2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 3 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 3 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 1 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 1 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 0 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 0 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if 1 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 1 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 2*nums.index(val)+1 < len(nums):",
      "mutated_line": "if -2 * nums.index(val) + 1 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if -2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) - 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) - 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) * 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) * 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 3 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 3 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 1 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 1 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 0 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 0 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if 1 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 1 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 2*nums.index(val)+2 < len(nums):",
      "mutated_line": "if -2 * nums.index(val) + 2 < len(nums):",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if -2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) - 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) - 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) * 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) * 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 / nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 / nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 + nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 + nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 ** nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 ** nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 0])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 0])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 0])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 0])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + -1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + -1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 / nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 / nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 + nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 + nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 ** nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 ** nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 3])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 3])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 0])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 0])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[2 * nums.index(val) + -2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + -2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[3 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[3 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[1 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[1 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[0 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[0 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[1 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[1 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append(nums[2*nums.index(val)+1])",
      "mutated_line": "queue.append(nums[-2 * nums.index(val) + 1])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[-2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[3 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[3 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[1 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[1 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[0 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[0 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[1 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[1 * nums.index(val) + 2])\n    return depth"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append(nums[2*nums.index(val)+2])",
      "mutated_line": "queue.append(nums[-2 * nums.index(val) + 2])",
      "code": "from collections import deque\n\ndef find_depth(nums):\n    if not nums:\n        return 0\n    nums.append(None)\n    queue = deque(nums)\n    depth = 0\n    while queue:\n        depth += 1\n        while True:\n            val = queue.popleft()\n            if val is None:\n                break\n            else:\n                if 2 * nums.index(val) + 1 < len(nums):\n                    queue.append(nums[2 * nums.index(val) + 1])\n                if 2 * nums.index(val) + 2 < len(nums):\n                    queue.append(nums[-2 * nums.index(val) + 2])\n    return depth"
    }
  ]
}