{
  "task_id": "cf_18349",
  "entry_point": "calculate_shortest_distance",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if current == target:",
      "mutated_line": "if current != target:",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current != target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(2, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(0, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(-1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, -1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 1, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, -1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 1), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (+1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, -1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 1, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, -1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 1), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (-1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (1, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 2, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 0, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, -1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 1), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (-1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (1, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, +1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, -1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 1), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (-1, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (1, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, -1, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 1, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 2), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 0), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, -1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (-1, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (1, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, -1, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 1, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, +1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(1, start)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(1, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(-1, start)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(-1, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "queue = [(0, start)]",
      "mutated_line": "queue = [(1, start)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(1, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) or 0 <= y < len(grid[0]) or 0 <= z < len(grid[0][0]) or ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) or 0 <= y < len(grid[0]) or 0 <= z < len(grid[0][0]) or ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-2, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-0, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (--1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -2, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -0, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, --1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -2)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -0)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]",
      "mutated_line": "movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, --1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] - movement[0], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] - movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] * movement[0], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] * movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] - movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] - movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] * movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] * movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] - movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] - movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] * movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] * movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 < x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 < x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 > x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 > x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 == x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 == x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 < y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 < y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 > y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 > y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 == y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 == y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 < z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 < z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 > z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 > z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 == z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 == z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if -1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if -1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 1 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and -1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and -1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 1 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (-1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (-1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (1 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist - (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist - (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist * (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist * (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[1] + movement[0], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[1] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[-1] + movement[0], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[-1] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[1] + movement[0], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[1] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[1], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[1], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[-1], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[-1], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[1], current[1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[1], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[2] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[2] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[0] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[0] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[0] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[0] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[-1] + movement[1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[-1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[2], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[2], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[0], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[0], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[0], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[0], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[-1], current[2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[-1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[3] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[3] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[1] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[1] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[0] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[0] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[1] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[1] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[-2] + movement[2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[-2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[3])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[3])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[1])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[1])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[0])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[0])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[1])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[1])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "x, y, z = current[0] + movement[0], current[1] + movement[1], current[2] + movement[2]",
      "mutated_line": "(x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[-2])",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[-2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not grid[x][y][z][0]:",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][1]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not grid[x][y][z][0]:",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][-1]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if not grid[x][y][z][0]:",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][1]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) * 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) * 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2 + 0.5)",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2 + 0.5)\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[-1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[-1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[1]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][1])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][1])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][-1])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][-1])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][1])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][1])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 - movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 - movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2) * movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2) * movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 1.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 1.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** -0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** -0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 1",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 1\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** -0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** -0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[1][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[1][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[-1][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[-1][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and (0 <= z < len(grid[0][0])) and (x, y, z) not in visited:",
      "mutated_line": "if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[1][0])) and ((x, y, z) not in visited):",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[1][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 - movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 - movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 * movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 * movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] * 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] * 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + (movement[2] + 2)) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + (movement[2] + 2)) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] * 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] * 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] + 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] + 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] * 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] * 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + (movement[1] + 2) + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + (movement[1] + 2) + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 3) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 3) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 1) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 1) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 0) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 0) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 1) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 1) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** -2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[2] ** -2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 3 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 3 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 1 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 1 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 0 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 0 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 1 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 1 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** -2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** -2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 3 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 3 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 1 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 1 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 0 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 0 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 1 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 1 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** -2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** -2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[3] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[3] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[1] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[1] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[0] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[0] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[1] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[1] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[-2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[1] ** 2 + movement[-2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[-1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[-1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[1] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[2] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[2] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[0] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[0] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[0] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[0] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "neighbor_dist = dist + ((movement[0] ** 2 + movement[1] ** 2 + movement[2] ** 2) ** 0.5)",
      "mutated_line": "neighbor_dist = dist + (movement[0] ** 2 + movement[-1] ** 2 + movement[2] ** 2) ** 0.5",
      "code": "import heapq\n\ndef calculate_shortest_distance(grid, start, target):\n    \"\"\"\n    Calculate the shortest distance between two points in a 3D grid while avoiding obstacles.\n\n    Args:\n    grid (3D array): A 3D grid representing the environment and obstacles.\n    start (tuple): The coordinates of the starting point.\n    target (tuple): The coordinates of the target point.\n\n    Returns:\n    float: The shortest distance between the two points while avoiding the obstacles.\n    \"\"\"\n    movements = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]\n    queue = [(0, start)]\n    visited = set([start])\n    while queue:\n        (dist, current) = heapq.heappop(queue)\n        if current == target:\n            return dist\n        for movement in movements:\n            (x, y, z) = (current[0] + movement[0], current[1] + movement[1], current[2] + movement[2])\n            if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and (0 <= z < len(grid[0][0])) and ((x, y, z) not in visited):\n                if not grid[x][y][z][0]:\n                    neighbor_dist = dist + (movement[0] ** 2 + movement[-1] ** 2 + movement[2] ** 2) ** 0.5\n                    visited.add((x, y, z))\n                    heapq.heappush(queue, (neighbor_dist, (x, y, z)))\n    return float('inf')"
    }
  ]
}