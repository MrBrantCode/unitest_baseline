{
  "task_id": "cf_16990",
  "entry_point": "breadthFirstSearch",
  "mutant_count": 11,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if target not in parent:",
      "mutated_line": "if target in parent:",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while current is not None:",
      "mutated_line": "while current is None:",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if current == target:",
      "mutated_line": "if current != target:",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current != target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(1)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(1)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(-1)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(-1)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "current = queue.pop(0)",
      "mutated_line": "current = queue.pop(1)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(1)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if neighbor not in visited:",
      "mutated_line": "if neighbor in visited:",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(0, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(1, current)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(1, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(-1, current)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(-1, current)\n        current = parent[current]\n    return path"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path.insert(0, current)",
      "mutated_line": "path.insert(1, current)",
      "code": "def breadthFirstSearch(graph, start, target):\n    \"\"\"\n    Performs a breadth-first search in a weighted graph to find the shortest path \n    from the start vertex to the target vertex.\n\n    Args:\n    graph (dict): A dictionary representing the graph where each key is a vertex \n                  and its corresponding value is another dictionary with the \n                  neighboring vertices as keys and their respective edge weights \n                  as values.\n    start (str): The starting vertex.\n    target (str): The target vertex.\n\n    Returns:\n    list: The shortest path as a list of vertices. If the target vertex is not \n          found, returns None.\n    \"\"\"\n    queue = [start]\n    visited = set()\n    parent = {start: None}\n    while queue:\n        current = queue.pop(0)\n        if current == target:\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n                parent[neighbor] = current\n    if target not in parent:\n        return None\n    path = []\n    current = target\n    while current is not None:\n        path.insert(1, current)\n        current = parent[current]\n    return path"
    }
  ]
}