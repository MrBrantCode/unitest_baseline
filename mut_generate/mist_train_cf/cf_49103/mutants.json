{
  "task_id": "cf_49103",
  "entry_point": "mandelbrot_set",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=2, x_off=0, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=2, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=0, x_off=0, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=0, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=0, x_off=0, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=0, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=-1, x_off=0, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=-1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=1, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=1, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=-1, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=-1, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=1, y_off=0, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=1, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=1, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=1, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=-1, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=-1, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=1, max_iter=256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=1, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=257):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=257):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=255):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=255):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=0):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=0):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=1):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=1):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):",
      "mutated_line": "def mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=-256):",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=-256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"Generates a Mandelbrot set.",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"\"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = np.linspace(x_off - zoom, x_off + zoom, width)",
      "mutated_line": "x = np.linspace(x_off + zoom, x_off + zoom, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off + zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = np.linspace(x_off - zoom, x_off + zoom, width)",
      "mutated_line": "x = np.linspace(x_off * zoom, x_off + zoom, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off * zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = np.linspace(x_off - zoom, x_off + zoom, width)",
      "mutated_line": "x = np.linspace(x_off - zoom, x_off - zoom, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off - zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "x = np.linspace(x_off - zoom, x_off + zoom, width)",
      "mutated_line": "x = np.linspace(x_off - zoom, x_off * zoom, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off * zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = np.linspace(y_off - zoom, y_off + zoom, height)",
      "mutated_line": "y = np.linspace(y_off + zoom, y_off + zoom, height)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off + zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = np.linspace(y_off - zoom, y_off + zoom, height)",
      "mutated_line": "y = np.linspace(y_off * zoom, y_off + zoom, height)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off * zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = np.linspace(y_off - zoom, y_off + zoom, height)",
      "mutated_line": "y = np.linspace(y_off - zoom, y_off - zoom, height)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off - zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "y = np.linspace(y_off - zoom, y_off + zoom, height)",
      "mutated_line": "y = np.linspace(y_off - zoom, y_off * zoom, height)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off * zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = (iteration << 21 | iteration << 10) & iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = (iteration << 21 | iteration << 10) & iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = (iteration << 21 | iteration << 10) ^ iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = (iteration << 21 | iteration << 10) ^ iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pixels = np.arange(width*height, dtype=np.uint32).reshape(height, width)",
      "mutated_line": "pixels = np.arange(width / height, dtype=np.uint32).reshape(height, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width / height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pixels = np.arange(width*height, dtype=np.uint32).reshape(height, width)",
      "mutated_line": "pixels = np.arange(width + height, dtype=np.uint32).reshape(height, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width + height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pixels = np.arange(width*height, dtype=np.uint32).reshape(height, width)",
      "mutated_line": "pixels = np.arange(width ** height, dtype=np.uint32).reshape(height, width)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width ** height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 - 0j, x_value + y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 - 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 * 0j, x_value + y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 * 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 + 0j, x_value - y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value - y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 + 0j, x_value * (y_value * 1j))",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value * (y_value * 1j))\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) >= 2:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) >= 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) <= 2:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) <= 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) != 2:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) != 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "z = z*z + c",
      "mutated_line": "z = z * z - c",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z - c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "z = z*z + c",
      "mutated_line": "z = z * z * c",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z * c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 & iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 & iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 ^ iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 ^ iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration / 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration / 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration + 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration + 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration ** 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration ** 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (1 + 0j, x_value + y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (1 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (-1 + 0j, x_value + y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (-1 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (1 + 0j, x_value + y_value * 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (1 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 + 0j, x_value + y_value / 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value / 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 + 0j, x_value + (y_value + 1j))",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + (y_value + 1j))\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z, c = 0 + 0j, x_value + y_value*1j",
      "mutated_line": "(z, c) = (0 + 0j, x_value + y_value ** 1j)",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value ** 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) > 3:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 3:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) > 1:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 1:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) > 0:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 0:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) > 1:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 1:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if abs(z) > 2:",
      "mutated_line": "if abs(z) > -2:",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > -2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "z = z*z + c",
      "mutated_line": "z = z / z + c",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z / z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "z = z*z + c",
      "mutated_line": "z = z + z + c",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z + z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "z = z*z + c",
      "mutated_line": "z = z ** z + c",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z ** z + c\n            color = iteration << 21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration * 9",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 9\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration * 7",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 7\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration * 0",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 0\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration * 1",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * 1\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 10 | iteration * -8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 10 | iteration * -8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 22 | iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 22 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 20 | iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 20 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 0 | iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 0 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 1 | iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 1 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << -21 | iteration << 10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << -21 | iteration << 10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 11 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 11 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 9 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 9 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 0 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 0 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << 1 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << 1 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = iteration << 21 | iteration << 10 | iteration*8",
      "mutated_line": "color = iteration << 21 | iteration << -10 | iteration * 8",
      "code": "import numpy as np\n\ndef mandelbrot_set(width, height, zoom=1, x_off=0, y_off=0, max_iter=256):\n    \"\"\"Generates a Mandelbrot set.\n\n    Parameters:\n    width (int): The width of the output image.\n    height (int): The height of the output image.\n    zoom (float): The zoom level.\n    x_off (float): The x offset.\n    y_off (float): The y offset.\n    max_iter (int): The maximum number of iterations.\n\n    Returns:\n    ndarray: A 2D array representing the Mandelbrot set.\n    \"\"\"\n    pixels = np.arange(width * height, dtype=np.uint32).reshape(height, width)\n    x = np.linspace(x_off - zoom, x_off + zoom, width)\n    y = np.linspace(y_off - zoom, y_off + zoom, height)\n    for (x_index, x_value) in enumerate(x):\n        for (y_index, y_value) in enumerate(y):\n            (z, c) = (0 + 0j, x_value + y_value * 1j)\n            for iteration in range(max_iter):\n                if abs(z) > 2:\n                    break\n                z = z * z + c\n            color = iteration << 21 | iteration << -10 | iteration * 8\n            pixels[y_index, x_index] = color\n    return pixels"
    }
  ]
}