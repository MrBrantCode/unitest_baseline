{
  "task_id": "cf_30084",
  "entry_point": "entrance",
  "mutant_count": 12,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if subnet_mask is None:",
      "mutated_line": "return (True, binary_ip, None, None)",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is not None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True, binary_ip, str(network.network_address), str(network.broadcast_address)",
      "mutated_line": "return (False, binary_ip, str(network.network_address), str(network.broadcast_address))",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (False, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary_ip = bin(int(ip_obj))[2:]",
      "mutated_line": "binary_ip = bin(int(ip_obj))[3:]",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[3:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary_ip = bin(int(ip_obj))[2:]",
      "mutated_line": "binary_ip = bin(int(ip_obj))[1:]",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[1:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary_ip = bin(int(ip_obj))[2:]",
      "mutated_line": "binary_ip = bin(int(ip_obj))[0:]",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[0:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary_ip = bin(int(ip_obj))[2:]",
      "mutated_line": "binary_ip = bin(int(ip_obj))[1:]",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[1:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "binary_ip = bin(int(ip_obj))[2:]",
      "mutated_line": "binary_ip = bin(int(ip_obj))[-2:]",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[-2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True, binary_ip, None, None",
      "mutated_line": "return (False, binary_ip, None, None)",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (False, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "network = ipaddress.ip_network(f\"{address}/{subnet_mask}\", strict=False)",
      "mutated_line": "return (True, binary_ip, str(network.network_address), str(network.broadcast_address))",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "network = ipaddress.ip_network(f\"{address}/{subnet_mask}\", strict=False)",
      "mutated_line": "return (True, binary_ip, str(network.network_address), str(network.broadcast_address))",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=True)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (False, None, None, None)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return False, None, None, None",
      "mutated_line": "return (True, None, None, None)",
      "code": "import ipaddress\n\ndef entrance(address: str, subnet_mask: str=None) -> (bool, str, str, str):\n    \"\"\"\n    Validates the IP address (IPv4 or IPv6), converts it to binary format, \n    and calculates the network address and broadcast address given a subnet mask.\n\n    Args:\n        address (str): The IP address string.\n        subnet_mask (str, optional): The subnet mask string. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the validation result, binary IP address, \n        network address, and broadcast address.\n    \"\"\"\n    try:\n        ip_obj = ipaddress.ip_address(address)\n        binary_ip = bin(int(ip_obj))[2:]\n        if subnet_mask is None:\n            return (True, binary_ip, None, None)\n        network = ipaddress.ip_network(f'{address}/{subnet_mask}', strict=False)\n        return (True, binary_ip, str(network.network_address), str(network.broadcast_address))\n    except ValueError:\n        return (True, None, None, None)"
    }
  ]
}