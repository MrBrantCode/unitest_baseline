{
  "task_id": "cf_94455",
  "entry_point": "postfix_to_infix",
  "mutant_count": 6,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if char not in operators:",
      "mutated_line": "if char in operators:",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['+', '-', '*', '/'])\n    for char in expression:\n        if char in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append('({}{}{})'.format(operand1, char, operand2))\n    return stack.pop()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "operators = set(['+', '-', '*', '/'])",
      "mutated_line": "operators = set(['', '-', '*', '/'])",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['', '-', '*', '/'])\n    for char in expression:\n        if char not in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append('({}{}{})'.format(operand1, char, operand2))\n    return stack.pop()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "operators = set(['+', '-', '*', '/'])",
      "mutated_line": "operators = set(['+', '', '*', '/'])",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['+', '', '*', '/'])\n    for char in expression:\n        if char not in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append('({}{}{})'.format(operand1, char, operand2))\n    return stack.pop()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "operators = set(['+', '-', '*', '/'])",
      "mutated_line": "operators = set(['+', '-', '', '/'])",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['+', '-', '', '/'])\n    for char in expression:\n        if char not in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append('({}{}{})'.format(operand1, char, operand2))\n    return stack.pop()"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "operators = set(['+', '-', '*', '/'])",
      "mutated_line": "operators = set(['+', '-', '*', ''])",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['+', '-', '*', ''])\n    for char in expression:\n        if char not in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append('({}{}{})'.format(operand1, char, operand2))\n    return stack.pop()"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "stack.append('({}{}{})'.format(operand1, char, operand2))",
      "mutated_line": "stack.append(''.format(operand1, char, operand2))",
      "code": "def postfix_to_infix(expression):\n    stack = []\n    operators = set(['+', '-', '*', '/'])\n    for char in expression:\n        if char not in operators:\n            stack.append(char)\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            stack.append(''.format(operand1, char, operand2))\n    return stack.pop()"
    }
  ]
}