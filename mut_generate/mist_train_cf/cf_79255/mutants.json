{
  "task_id": "cf_79255",
  "entry_point": "identify_quadrilateral",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e or alpha == beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e or alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d != e and alpha == beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d != e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha != beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha != beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 'Square'",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return ''\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e or alpha != beta or abs(alpha - beta) == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e or alpha != beta or abs(alpha - beta) == math.pi / 2:\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi * 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi * 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi // 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi // 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d != e and alpha != beta and (abs(alpha - beta) == math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d != e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha == beta and (abs(alpha - beta) == math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha == beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) != math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) != math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 'Rhombus'",
      "mutated_line": "elif d != e and alpha == beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return ''\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e or alpha == beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e or alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi / 3:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 3:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi / 1:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 1:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi / 0:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 0:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi / 1:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 1:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if d == e and alpha == beta == math.pi/2:",
      "mutated_line": "if d == e and alpha == beta == math.pi / -2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / -2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi * 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi * 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi // 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi // 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d == e and alpha == beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d == e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha != beta == math.pi / 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha != beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Rectangle'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return ''\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 'Parallelogram'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha + beta) == math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha + beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha * beta) == math.pi / 2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha * beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 3):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 3):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 1):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 1):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 0):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 0):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 1):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 1):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "elif d == e and alpha != beta and abs(alpha-beta) == math.pi/2:",
      "mutated_line": "elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / -2):",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / -2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi * 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi * 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi // 2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi // 2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi / 3:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 3:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi / 1:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 1:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi / 0:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 0:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi / 1:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / 1:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif d != e and alpha == beta == math.pi/2:",
      "mutated_line": "elif d != e and alpha == beta == math.pi / -2:",
      "code": "import math\n\ndef identify_quadrilateral(d, e, alpha, beta):\n    alpha = math.radians(alpha)\n    beta = math.radians(beta)\n    if d == e and alpha == beta == math.pi / 2:\n        return 'Square'\n    elif d == e and alpha != beta and (abs(alpha - beta) == math.pi / 2):\n        return 'Rhombus'\n    elif d != e and alpha == beta == math.pi / -2:\n        return 'Rectangle'\n    else:\n        return 'Parallelogram'"
    }
  ]
}