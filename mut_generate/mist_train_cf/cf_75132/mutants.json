{
  "task_id": "cf_75132",
  "entry_point": "numIslands2",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "parent, rank, count, res = {}, {}, 0, []",
      "mutated_line": "(parent, rank, count, res) = ({}, {}, 1, [])",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 1, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "parent, rank, count, res = {}, {}, 0, []",
      "mutated_line": "(parent, rank, count, res) = ({}, {}, -1, [])",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, -1, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "parent, rank, count, res = {}, {}, 0, []",
      "mutated_line": "(parent, rank, count, res) = ({}, {}, 1, [])",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 1, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if parent[x] != x:",
      "mutated_line": "if parent[x] == x:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] == x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if xr != yr:",
      "mutated_line": "if xr == yr:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr == yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "count -= 1",
      "mutated_line": "count += 1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count += 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "index = x * n + y",
      "mutated_line": "index = x * n - y",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n - y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "index = x * n + y",
      "mutated_line": "index = x * n * y",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n * y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index not in parent:",
      "mutated_line": "if index in parent:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count -= 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rank[xr] < rank[yr]:",
      "mutated_line": "if rank[xr] <= rank[yr]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] <= rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rank[xr] < rank[yr]:",
      "mutated_line": "if rank[xr] >= rank[yr]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] >= rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if rank[xr] < rank[yr]:",
      "mutated_line": "if rank[xr] != rank[yr]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] != rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if rank[xr] == rank[yr]:",
      "mutated_line": "if rank[xr] != rank[yr]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] != rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "rank[xr] += 1",
      "mutated_line": "rank[xr] -= 1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] -= 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count -= 1",
      "mutated_line": "count -= 2",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 2\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count -= 1",
      "mutated_line": "count -= 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 0\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count -= 1",
      "mutated_line": "count -= 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 0\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count -= 1",
      "mutated_line": "count -= -1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= -1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "index = x * n + y",
      "mutated_line": "index = x / n + y",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x / n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "index = x * n + y",
      "mutated_line": "index = x + n + y",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x + n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "index = x * n + y",
      "mutated_line": "index = x ** n + y",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x ** n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "rank[index] = 0",
      "mutated_line": "rank[index] = 1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 1\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "rank[index] = 0",
      "mutated_line": "rank[index] = -1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = -1\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "rank[index] = 0",
      "mutated_line": "rank[index] = 1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 1\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 2\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 0\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 0\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += -1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nindex = nx * n + ny",
      "mutated_line": "nindex = nx * n - ny",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n - ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nindex = nx * n + ny",
      "mutated_line": "nindex = nx * n * ny",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n * ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or nindex in parent:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m or 0 <= ny < n or nindex in parent:\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rank[xr] += 1",
      "mutated_line": "rank[xr] += 2",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 2\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rank[xr] += 1",
      "mutated_line": "rank[xr] += 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 0\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rank[xr] += 1",
      "mutated_line": "rank[xr] += 0",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 0\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "rank[xr] += 1",
      "mutated_line": "rank[xr] += -1",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += -1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x - dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x * dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y - dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y * dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nindex = nx * n + ny",
      "mutated_line": "nindex = nx / n + ny",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx / n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nindex = nx * n + ny",
      "mutated_line": "nindex = nx + n + ny",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx + n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "nindex = nx * n + ny",
      "mutated_line": "nindex = nx ** n + ny",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx ** n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 < nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 > nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 == nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 < ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 > ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 == ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (nindex not in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex not in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 1 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if -1 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 1 <= nx < m and 0 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 1 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and -1 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and nindex in parent:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (nindex in parent):",
      "code": "def numIslands2(m, n, positions):\n    (parent, rank, count, res) = ({}, {}, 0, [])\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        (xr, yr) = (find(x), find(y))\n        if xr != yr:\n            if rank[xr] < rank[yr]:\n                (xr, yr) = (yr, xr)\n            if rank[xr] == rank[yr]:\n                rank[xr] += 1\n            parent[yr] = xr\n            count -= 1\n    for (x, y) in positions:\n        index = x * n + y\n        if index not in parent:\n            parent[index] = index\n            rank[index] = 0\n            count += 1\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            nindex = nx * n + ny\n            if 0 <= nx < m and 1 <= ny < n and (nindex in parent):\n                union(index, nindex)\n        res.append(count)\n    return res"
    }
  ]
}