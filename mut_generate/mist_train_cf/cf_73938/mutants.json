{
  "task_id": "cf_73938",
  "entry_point": "min_leaps",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) - 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) - 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) * 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) * 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] / (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] / (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] + (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] + (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] ** (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] ** (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = -1\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -1 or dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 or dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 3",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 3\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 1\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 0\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 1\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=0)) + -2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + -2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point - 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point - 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point * 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point * 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[1] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[-1] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[1] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(1)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(-1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(-1)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(1)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if c == x and dp[c] <= s:",
      "mutated_line": "if c == x or dp[c] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x or dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 1 >= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 >= s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 1 <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 <= s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 1 != s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 != s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point or dp[c + a] == -1 or c + a not in prohibited:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point or dp[c + a] == -1 or c + a not in prohibited:\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 or dp[c - b] == -1 or c - b not in prohibited or (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 or dp[c - b] == -1 or c - b not in prohibited or (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] == -1 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] == -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -1 and dp[x] < s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] < s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -1 and dp[x] > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] > s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -1 and dp[x] == s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] == s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return +1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [+1] * (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [+1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point + 2)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 2)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point + 0)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 0)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point + 0)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 0)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-1] * (max_point + -1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + -1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if c == x and dp[c] <= s:",
      "mutated_line": "if c != x and dp[c] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c != x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if c == x and dp[c] <= s:",
      "mutated_line": "if c == x and dp[c] < s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] < s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if c == x and dp[c] <= s:",
      "mutated_line": "if c == x and dp[c] > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] > s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if c == x and dp[c] <= s:",
      "mutated_line": "if c == x and dp[c] == s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] == s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] - 1 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] - 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] * 1 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] * 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a < max_point and dp[c + a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a < max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a > max_point and dp[c + a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a > max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a == max_point and dp[c + a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a == max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] != -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] != -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -1 and (c + a in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] - 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] - 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] * 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] * 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b > 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b > 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b < 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b < 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b == 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b == 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] != -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] != -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c - b in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] == 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] == 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] - 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] - 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] * 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] * 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != +1 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != +1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-2] * (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-2] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-0] * (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-0] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [-0] * (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-0] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [-1] * (max_point + 1)",
      "mutated_line": "dp = [--1] * (max_point + 1)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [--1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 2 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 2 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 0 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 0 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + 0 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 0 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dp[c] + 1 > s:",
      "mutated_line": "if dp[c] + -1 > s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + -1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c - a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c - a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c * a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c * a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == +1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == +1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -1 and (c - a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c - a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -1 and (c * a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c * a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c - a] = dp[c] + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c - a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c * a] = dp[c] + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c * a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] + 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 2\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] + 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 0\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] + 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 0\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[c + a] = dp[c] + 1",
      "mutated_line": "dp[c + a] = dp[c] + -1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + -1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append(c + a)",
      "mutated_line": "q.append(c - a)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c - a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append(c + a)",
      "mutated_line": "q.append(c * a)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c * a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c + b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c + b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c * b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c * b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= -1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= -1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 1 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == +1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == +1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c + b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c + b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c * b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c * b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 1):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 1):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != -1):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != -1):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 1):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 1):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c + b] = dp[c] + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c + b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c * b] = dp[c] + 1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c * b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] + 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 2\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] + 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 0\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] + 0",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 0\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[c - b] = dp[c] + 1",
      "mutated_line": "dp[c - b] = dp[c] + -1",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + -1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "q.append(c - b)",
      "mutated_line": "q.append(c + b)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c + b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "q.append(c - b)",
      "mutated_line": "q.append(c * b)",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c * b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -2 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -2 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -0 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -0 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != -0 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -0 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if dp[x] != -1 and dp[x] <= s:",
      "mutated_line": "if dp[x] != --1 and dp[x] <= s:",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != --1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=1)) + 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=1)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=-1)) + 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=-1)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "max_point = max(a, b, x, max(prohibited, default=0)) + 2",
      "mutated_line": "max_point = max(a, b, x, max(prohibited, default=1)) + 2",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=1)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c - a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c - a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c * a] == -1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c * a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -2 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -2 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -0 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -0 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == -0 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -0 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c + a <= max_point and dp[c + a] == -1 and c + a not in prohibited:",
      "mutated_line": "if c + a <= max_point and dp[c + a] == --1 and (c + a not in prohibited):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == --1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c + b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c + b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c * b] == -1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c * b] == -1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -2 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -2 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -0 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -0 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == -0 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == -0 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if c - b >= 0 and dp[c - b] == -1 and c - b not in prohibited and dp[c] != 0:",
      "mutated_line": "if c - b >= 0 and dp[c - b] == --1 and (c - b not in prohibited) and (dp[c] != 0):",
      "code": "from collections import deque\n\ndef min_leaps(prohibited, a, b, x, s):\n    prohibited = set(prohibited)\n    max_point = max(a, b, x, max(prohibited, default=0)) + 2\n    dp = [-1] * (max_point + 1)\n    dp[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        c = q.popleft()\n        if c == x and dp[c] <= s:\n            return dp[c]\n        if dp[c] + 1 > s:\n            break\n        if c + a <= max_point and dp[c + a] == -1 and (c + a not in prohibited):\n            dp[c + a] = dp[c] + 1\n            q.append(c + a)\n        if c - b >= 0 and dp[c - b] == --1 and (c - b not in prohibited) and (dp[c] != 0):\n            dp[c - b] = dp[c] + 1\n            q.append(c - b)\n    if dp[x] != -1 and dp[x] <= s:\n        return dp[x]\n    else:\n        return -1"
    }
  ]
}