{
  "task_id": "cf_34854",
  "entry_point": "update_function_array",
  "mutant_count": 202,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) / function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) / function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) + function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) + function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = (np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis])) ** function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = (np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis])) ** function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax - 1)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax - 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax * 1)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax * 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) / np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) / np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = (np.sqrt(2 * index[2:] + 1) + np.cos(theta[:, np.newaxis])) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = (np.sqrt(2 * index[2:] + 1) + np.cos(theta[:, np.newaxis])) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) ** np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) ** np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(3, nmax + 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(3, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(1, nmax + 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(1, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(0, nmax + 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(0, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(1, nmax + 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(1, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(-2, nmax + 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(-2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax - 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax - 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax * 1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax * 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] + np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] + np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] * (np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m])",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] * (np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m])\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax + 2)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 2)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax + 0)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 0)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax + 0)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 0)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "index = np.arange(nmax + 1)",
      "mutated_line": "index = np.arange(nmax + -1)",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + -1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax + 2):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 2):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax + 0):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 0):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax + 0):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 0):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for row in range(2, nmax + 1):",
      "mutated_line": "for row in range(2, nmax + -1):",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + -1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) / function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) / function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) + function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) + function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = (np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis])) ** function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = (np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis])) ** function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) / function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) / function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - (np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) + function_array[:, n - 2, m])",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - (np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) + function_array[:, n - 2, m])\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) ** function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) ** function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] - 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] - 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] * 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] * 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "m = index[0:-row]",
      "mutated_line": "m = index[1:-row]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[1:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "m = index[0:-row]",
      "mutated_line": "m = index[-1:-row]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[-1:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "m = index[0:-row]",
      "mutated_line": "m = index[1:-row]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[1:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "m = index[0:-row]",
      "mutated_line": "m = index[0:+row]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:+row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) / np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) / np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = (np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) + np.cos(theta[:, np.newaxis])) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = (np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) + np.cos(theta[:, np.newaxis])) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) ** np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) ** np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[3:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[3:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[1:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[1:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[0:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[0:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[1:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[1:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[-2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[-2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[2:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[2:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[0:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[0:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[0:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[0:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[-1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[-1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:+1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:+1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 / index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 / index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 + index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 + index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 ** index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 ** index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 2) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 2) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 0) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 0) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 0) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 0) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + -1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + -1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) * (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) * (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) // (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) // (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-2]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-2]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-0]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-0]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-0]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-0]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:--1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:--1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(3 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(3 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(1 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(1 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(0 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(0 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(1 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(1 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(-2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(-2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[2:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[2:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[0:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[0:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[0:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[0:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[-1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[-1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:+1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:+1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[2:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[2:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[0:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[0:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[0:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[0:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[-1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[-1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:+1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:+1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) * (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) * (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) // (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) // (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n + 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n + 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n * 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n * 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) / (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) / (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) + (n + m - 1.0)) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) + (n + m - 1.0)) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m)) ** (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m)) ** (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n - m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n - m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n * m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n * m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n + 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n + 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n * 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n * 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-2], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-2], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-0], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-0], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-0], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-0], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:--1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:--1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-2]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-2]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-0]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-0]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-0]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-0]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "function_array[:, index[1:-1], index[1:-1]]",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:--1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:--1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) / (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) / (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt(((2.0 * n - 1.0) / (n - m) + (2.0 * n + 1.0)) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt(((2.0 * n - 1.0) / (n - m) + (2.0 * n + 1.0)) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt(((2.0 * n - 1.0) / (n - m)) ** (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt(((2.0 * n - 1.0) / (n - m)) ** (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n - m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n - m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n * m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n * m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 2, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 2, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 0, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 0, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 0, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 0, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - -1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - -1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) * (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) * (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) // (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) // (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m + 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m + 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * ((n + m) * 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * ((n + m) * 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 3, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 3, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 1, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 1, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 0, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 0, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 1, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 1, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - -2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - -2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[3:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[3:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[1:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[1:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[0:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[0:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[1:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[1:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * \\",
      "mutated_line": "function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[-2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[-2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) * (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) * (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) // (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) // (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n - 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n - 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n * 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n * 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) / (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) / (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) + (n - m - 1.0)) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0) + (n - m - 1.0)) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0)) ** (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(((2.0 * n + 1.0) / (2.0 * n - 3.0)) ** (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n + m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n + m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n * m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n * m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n - m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n - m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n * m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n * m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 2.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 2.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 0.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 0.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - -1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - -1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n + 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n + 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt(2.0 * n * 1.0 / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt(2.0 * n * 1.0 / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n + m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n + m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n * m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n * m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 / n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 / n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 + n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 + n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 ** n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 ** n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 2.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 2.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 0.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 0.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + -1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + -1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) * (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) * (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) // (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) // (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m + 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m + 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * ((n - m) * 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * ((n - m) * 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 / n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 / n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 + n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 + n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 ** n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 ** n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 2.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 2.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 0.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 0.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - -1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - -1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (3.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (3.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (1.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (1.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (1 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (1 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (-2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (-2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n - 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n - 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(2.0 * n * 1.0 / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt(2.0 * n * 1.0 / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n + 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n + 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n * 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n * 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n + m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n + m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n * m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n * m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 2.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 2.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 0.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 0.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - -1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - -1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((3.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((3.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((1.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((1.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((1 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((1 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * \\",
      "mutated_line": "function_array[:, n, m] = np.sqrt((-2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((-2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 / n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 / n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 + n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 + n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 ** n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 ** n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 2.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 2.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 0.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 0.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + -1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + -1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 / n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 / n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 + n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 + n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 ** n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 ** n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 4.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 4.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 2.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 2.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 1) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - 1) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - -3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (2.0 * n - -3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((3.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((3.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((1.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((1.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((1 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((1 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((-2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((-2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (3.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (3.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (1.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (1.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (1 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (1 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "np.sqrt((2.0 * n + 1.0) / (2.0 * n - 3.0) * (n - m - 1.0) / (n - m) *",
      "mutated_line": "function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (-2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]",
      "code": "import numpy as np\n\ndef update_function_array(function_array, nmax, theta):\n    index = np.arange(nmax + 1)\n    function_array[:, index[2:], index[1:-1]] = np.sqrt(2 * index[2:] + 1) * np.cos(theta[:, np.newaxis]) * function_array[:, index[1:-1], index[1:-1]]\n    for row in range(2, nmax + 1):\n        n = index[row:]\n        m = index[0:-row]\n        function_array[:, n, m] = np.sqrt((2.0 * n - 1.0) / (n - m) * (2.0 * n + 1.0) / (n + m)) * np.cos(theta[:, np.newaxis]) * function_array[:, n - 1, m] - np.sqrt((2.0 * n + 1.0) / (-2.0 * n - 3.0) * (n - m - 1.0) / (n - m) * (n + m - 1.0) / (n + m)) * function_array[:, n - 2, m]\n    return function_array"
    }
  ]
}