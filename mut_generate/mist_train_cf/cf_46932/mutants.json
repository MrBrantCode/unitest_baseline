{
  "task_id": "cf_46932",
  "entry_point": "shortestDistance",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if not grid or not grid[0]:",
      "mutated_line": "if not grid and (not grid[0]):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid and (not grid[0]):\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return +1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] / n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] + n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] ** n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] / n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] + n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] ** n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] and [-1])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] and [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -2\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -0\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -0\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return --1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "buildings = sum(val == 1 for line in grid for val in line)",
      "mutated_line": "buildings = sum((val != 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val != 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] / n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] / n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] + n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] + n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[False] ** n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] ** n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (False, 1, deque([(start_x, start_y, 0)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (False, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 2, deque([(start_x, start_y, 0)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 2, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 0, deque([(start_x, start_y, 0)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 0, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 0, deque([(start_x, start_y, 0)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 0, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, -1, deque([(start_x, start_y, 0)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, -1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if grid[x][y] == 1:",
      "mutated_line": "if grid[x][y] != 1:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] != 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or not grid[0]:",
      "mutated_line": "if not grid or not grid[1]:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[1]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or not grid[0]:",
      "mutated_line": "if not grid or not grid[-1]:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[-1]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if not grid or not grid[0]:",
      "mutated_line": "if not grid or not grid[1]:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[1]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "dist = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[1]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "dist = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[-1]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "m, n = len(grid), len(grid[0])",
      "mutated_line": "dist = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[1]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[1] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[-1] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist = [[0]*n for _ in range(m)]",
      "mutated_line": "reach = [[0] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[1] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[1] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[-1] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "reach = [[0]*n for _ in range(m)]",
      "mutated_line": "buildings = sum((val == 1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[1] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "buildings = sum(val == 1 for line in grid for val in line)",
      "mutated_line": "buildings = sum((val == 2 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 2 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "buildings = sum(val == 1 for line in grid for val in line)",
      "mutated_line": "buildings = sum((val == 0 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 0 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "buildings = sum(val == 1 for line in grid for val in line)",
      "mutated_line": "buildings = sum((val == 0 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 0 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "buildings = sum(val == 1 for line in grid for val in line)",
      "mutated_line": "buildings = sum((val == -1 for line in grid for val in line))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == -1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(2, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(2, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, -1), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (+1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, -1), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (-1, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 2), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, -1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (-1, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, +1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m or 0 <= ny < n or (not visited[nx][ny]) or (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m or 0 <= ny < n or (not visited[nx][ny]) or (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] -= d + 1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] -= d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "reach[nx][ny] += 1",
      "mutated_line": "reach[nx][ny] -= 1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] -= 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if grid[x][y] == 1:",
      "mutated_line": "if grid[x][y] == 2:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 2:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if grid[x][y] == 1:",
      "mutated_line": "if grid[x][y] == 0:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 0:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if grid[x][y] == 1:",
      "mutated_line": "if grid[x][y] == 0:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 0:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if grid[x][y] == 1:",
      "mutated_line": "if grid[x][y] == -1:",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == -1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [+1])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [+1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-2, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (--1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -2)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]",
      "mutated_line": "direct = [(1, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, --1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [[False]*n for _ in range(m)]",
      "mutated_line": "visited = [[True] * n for _ in range(m)]",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[True] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x - dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x * dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y - dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y * dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 < nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 < nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 > nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 > nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 == nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 == nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 < ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 < ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 > ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 > ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 == ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 == ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] != 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = False\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d - 1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d - 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d * 1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d * 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reach[nx][ny] += 1",
      "mutated_line": "reach[nx][ny] += 2",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 2\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reach[nx][ny] += 1",
      "mutated_line": "reach[nx][ny] += 0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 0\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reach[nx][ny] += 1",
      "mutated_line": "reach[nx][ny] += 0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 0\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "reach[nx][ny] += 1",
      "mutated_line": "reach[nx][ny] += -1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += -1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] or reach[i][j] == buildings] or [-1])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] or reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-2])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-0])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-0])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [--1])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [--1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 1)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 1)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, -1)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, -1)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[start_x][start_y], count1, queue = True, 1, deque([(start_x, start_y, 0)])",
      "mutated_line": "(visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 1)]))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 1)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if -1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if -1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and -1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and -1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 1 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == -1):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == -1):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0:",
      "mutated_line": "if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 1):",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 1):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d + 2",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 2\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d + 0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 0\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d + 0",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 0\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[nx][ny] += d + 1",
      "mutated_line": "dist[nx][ny] += d + -1",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + -1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])",
      "mutated_line": "return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] != buildings] or [-1])",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] != buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d - 1))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d - 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d * 1))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d * 1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d + 2))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 2))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d + 0))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 0))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d + 0))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + 0))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append((nx, ny, d + 1))",
      "mutated_line": "queue.append((nx, ny, d + -1))",
      "code": "from collections import deque\n\ndef shortestDistance(grid):\n    if not grid or not grid[0]:\n        return -1\n    (m, n) = (len(grid), len(grid[0]))\n    dist = [[0] * n for _ in range(m)]\n    reach = [[0] * n for _ in range(m)]\n    buildings = sum((val == 1 for line in grid for val in line))\n\n    def BFS(start_x, start_y):\n        direct = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n        (visited[start_x][start_y], count1, queue) = (True, 1, deque([(start_x, start_y, 0)]))\n        while queue:\n            (x, y, d) = queue.popleft()\n            for (dx, dy) in direct:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < m and 0 <= ny < n and (not visited[nx][ny]) and (grid[nx][ny] == 0):\n                    queue.append((nx, ny, d + -1))\n                    visited[nx][ny] = True\n                    dist[nx][ny] += d + 1\n                    reach[nx][ny] += 1\n    for x in range(m):\n        for y in range(n):\n            if grid[x][y] == 1:\n                BFS(x, y)\n    return min([dist[i][j] for i in range(m) for j in range(n) if not grid[i][j] and reach[i][j] == buildings] or [-1])"
    }
  ]
}