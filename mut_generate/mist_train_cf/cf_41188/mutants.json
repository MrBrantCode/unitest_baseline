{
  "task_id": "cf_41188",
  "entry_point": "game_of_life",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "count -= initial_state[row][col]",
      "mutated_line": "count += initial_state[row][col]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count += initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[0] / cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] / cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[0] + cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] + cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[0] ** cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] ** cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = -1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 1\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "count += initial_state[i][j]",
      "mutated_line": "count -= initial_state[i][j]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count -= initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(initial_state), len(initial_state[0])",
      "mutated_line": "(rows, cols) = (len(initial_state), len(initial_state[1]))",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[1]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(initial_state), len(initial_state[0])",
      "mutated_line": "(rows, cols) = (len(initial_state), len(initial_state[-1]))",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[-1]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "rows, cols = len(initial_state), len(initial_state[0])",
      "mutated_line": "(rows, cols) = (len(initial_state), len(initial_state[1]))",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[1]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[1] * cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[1] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[-1] * cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[-1] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "next_state = [[0] * cols for _ in range(rows)]",
      "mutated_line": "next_state = [[1] * cols for _ in range(rows)]",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[1] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(1, row - 1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(-1, row - 1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(-1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(1, row - 1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(1, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row + 1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row + 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row * 1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row * 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row - 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row - 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row * 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row * 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if initial_state[i][j] == 1:",
      "mutated_line": "if initial_state[i][j] != 1:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] != 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 2), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 2), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 0), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 0), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 0), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 0), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - -1), min(rows, row + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - -1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 3)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 3)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 1)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 1)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 0)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 0)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + 1)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 1)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(max(0, row - 1), min(rows, row + 2)):",
      "mutated_line": "for i in range(max(0, row - 1), min(rows, row + -2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + -2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(1, col - 1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(1, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(-1, col - 1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(-1, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(1, col - 1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(1, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col + 1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col + 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col * 1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col * 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col - 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col - 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col * 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col * 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if initial_state[i][j] == 1:",
      "mutated_line": "if initial_state[i][j] == 2:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 2:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if initial_state[i][j] == 1:",
      "mutated_line": "if initial_state[i][j] == 0:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 0:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if initial_state[i][j] == 1:",
      "mutated_line": "if initial_state[i][j] == 0:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 0:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if initial_state[i][j] == 1:",
      "mutated_line": "if initial_state[i][j] == -1:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == -1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 and live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 and live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors != 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 2), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 2), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 0), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 0), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 0), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 0), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - -1), min(cols, col + 2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - -1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 3)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 3)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 1)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 1)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 0)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 0)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + 1)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 1)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(max(0, col - 1), min(cols, col + 2)):",
      "mutated_line": "for j in range(max(0, col - 1), min(cols, col + -2)):",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + -2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors <= 2 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors <= 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors >= 2 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors >= 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors != 2 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors != 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors >= 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors >= 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors <= 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors <= 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors != 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors != 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 1\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = -1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = -1\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 1\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 2",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 2\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 0\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 0\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = -1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = -1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 4:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 2:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 0:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 1:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if live_neighbors == 3:",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == -3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 2\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 0\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 0\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "next_state[i][j] = 1",
      "mutated_line": "next_state[i][j] = 0",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = -1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 1\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = -1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = -1\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_state[i][j] = 0",
      "mutated_line": "next_state[i][j] = 1",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 1\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 3 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 3 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 1 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 0 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 0 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 1 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 1 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < -2 or live_neighbors > 3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < -2 or live_neighbors > 3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 4:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 4:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 2:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 2:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 0:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 0:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > 1:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 1:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if live_neighbors < 2 or live_neighbors > 3:",
      "mutated_line": "if live_neighbors < 2 or live_neighbors > -3:",
      "code": "def game_of_life(initial_state, num_generations):\n    (rows, cols) = (len(initial_state), len(initial_state[0]))\n    next_state = [[0] * cols for _ in range(rows)]\n\n    def count_live_neighbors(row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(rows, row + 2)):\n            for j in range(max(0, col - 1), min(cols, col + 2)):\n                count += initial_state[i][j]\n        count -= initial_state[row][col]\n        return count\n    for _ in range(num_generations):\n        for i in range(rows):\n            for j in range(cols):\n                live_neighbors = count_live_neighbors(i, j)\n                if initial_state[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > -3:\n                        next_state[i][j] = 0\n                    else:\n                        next_state[i][j] = 1\n                elif live_neighbors == 3:\n                    next_state[i][j] = 1\n                else:\n                    next_state[i][j] = 0\n        initial_state = [row[:] for row in next_state]\n    return next_state"
    }
  ]
}