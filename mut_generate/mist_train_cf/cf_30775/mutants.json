{
  "task_id": "cf_30775",
  "entry_point": "merge_intervals",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] > interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] > interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] < interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] < interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] == interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] == interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "merged = [intervals[0]]  # Initialize the merged list with the first interval",
      "mutated_line": "merged = [intervals[1]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[1]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "merged = [intervals[0]]  # Initialize the merged list with the first interval",
      "mutated_line": "merged = [intervals[-1]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[-1]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "merged = [intervals[0]]  # Initialize the merged list with the first interval",
      "mutated_line": "merged = [intervals[1]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[1]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for interval in intervals[1:]:",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[2:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for interval in intervals[1:]:",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[0:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for interval in intervals[1:]:",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[0:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for interval in intervals[1:]:",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[-1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][2] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][2] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][0] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][0] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][0] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][0] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][-1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][-1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] >= interval[1]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[1]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] >= interval[-1]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[-1]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-1][1] >= interval[1]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[1]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][2] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][2] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][0] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][0] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][0] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][0] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][-1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][-1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on the start value",
      "mutated_line": "merged = [intervals[0]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[1])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on the start value",
      "mutated_line": "merged = [intervals[0]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[-1])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "intervals.sort(key=lambda x: x[0])  # Sort intervals based on the start value",
      "mutated_line": "merged = [intervals[0]]",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[1])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[+1][1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[+1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[+1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[+1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][2], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][2], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][0], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][0], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][0], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][0], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][-1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][-1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[2])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[2])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[0])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[0])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[0])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[0])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-1][1], interval[-1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[-1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-2][1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-2][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-0][1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-0][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[-0][1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-0][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if merged[-1][1] >= interval[0]:  # Check for overlap",
      "mutated_line": "if merged[--1][1] >= interval[0]:",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[--1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-2][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-2][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-0][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-0][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-0][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-0][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[--1][1] = max(merged[-1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[--1][1] = max(merged[-1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[+1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[+1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-2][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-2][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-0][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-0][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[-0][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[-0][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged[-1][1] = max(merged[-1][1], interval[1])  # Merge the intervals",
      "mutated_line": "merged[-1][1] = max(merged[--1][1], interval[1])",
      "code": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1][1] = max(merged[--1][1], interval[1])\n        else:\n            merged.append(interval)\n    return merged"
    }
  ]
}