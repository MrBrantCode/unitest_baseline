{
  "task_id": "cf_56273",
  "entry_point": "minDistance",
  "mutant_count": 137,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] / (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] / (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] + (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] + (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] ** (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] ** (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] / (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] / (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] + (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] + (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] ** (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] ** (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 1\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = -1\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 1\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] + (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] + (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] * (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] * (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n - 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n - 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n * 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n * 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + 1] = prefix[i] - houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] - houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + 1] = prefix[i] * houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] * houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[0] / n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] / n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[0] + n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] + n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[0] ** n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] ** n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] -= prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] -= prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n - 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n - 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n * 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n * 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[-1] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[0] = 0",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(2, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(2, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(0, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(0, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(-1, n + 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(-1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n - 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n - 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n * 1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n * 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k >= 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k >= 1)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k <= 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k <= 1)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k != 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k != 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [1] * (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [1] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [-1] * (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [-1] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [1] * (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [1] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n + 2)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 2)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n + 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 0)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n + 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 0)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "prefix = [0]*(n+1)",
      "mutated_line": "prefix = [0] * (n + -1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + -1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i - 1] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i - 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i * 1] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i * 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) / 2",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) / 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) * 2",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) * 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) + (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) + (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) * (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) * (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] + houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] + houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += (prefix[j + 1] - prefix[mid + 1]) * (houses[mid] * (j - mid))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += (prefix[j + 1] - prefix[mid + 1]) * (houses[mid] * (j - mid))\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n + 2)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 2)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n + 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 0)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n + 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 0)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('inf')] * (n + -1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + -1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n + 2):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 2):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 0):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 0):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1, n+1):",
      "mutated_line": "for j in range(1, n + -1):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + -1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dp[i] != float('inf'):",
      "mutated_line": "if dp[i] == float('inf'):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] == float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[+1] - (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[+1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k > 2)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k > 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k > 0)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-1] - (k > -1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > -1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + 2] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 2] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + 0] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 0] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + 0] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 0] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prefix[i+1] = prefix[i] + houses[i]",
      "mutated_line": "prefix[i + -1] = prefix[i] + houses[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + -1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[1] * n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[-1] * n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cost = [[0]*n for _ in range(n)]",
      "mutated_line": "cost = [[1] * n for _ in range(n)]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i - j) // 2",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i - j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = i * j // 2",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = i * j // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) // 3",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 3\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) // 1",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 1\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) // 0",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 0\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) // 1",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 1\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mid = (i+j) // 2",
      "mutated_line": "mid = (i + j) // -2",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // -2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] / (mid - i + 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] / (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] + (mid - i + 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] + (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] ** (mid - i + 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] ** (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] + prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] + prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - prefix[mid + 1] * prefix[i]",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - prefix[mid + 1] * prefix[i]\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] + prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] + prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] * prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] * prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] / (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] / (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] - (houses[mid] + (j - mid))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - (houses[mid] + (j - mid))\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] ** (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] ** (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp = [float('inf')]*(n+1)",
      "mutated_line": "dp = [float('')] * (n + 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-2] - (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-2] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-0] - (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-0] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[-0] - (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-0] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return dp[-1] - (k > 1)",
      "mutated_line": "return dp[--1] - (k > 1)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[--1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i - 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i - 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * ((mid - i) * 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * ((mid - i) * 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j + mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j + mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j * mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j * mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dp[i] != float('inf'):",
      "mutated_line": "if dp[i] != float(''):",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float(''):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] - (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] - (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], (dp[i] + cost[i][j - 1]) * (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], (dp[i] + cost[i][j - 1]) * (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid + i + 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid + i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid * i + 1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid * i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 2) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 2) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 0) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 0) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 0) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 0) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + -1) - (prefix[mid + 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + -1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid - 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid - 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid * 1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid * 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j - 1] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j - 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j * 1] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j * 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid - 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid - 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid * 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid * 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] - cost[i][j - 1] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] - cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] * cost[i][j - 1] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] * cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k >= 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k >= 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k <= 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k <= 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k != 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k != 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 2] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 2] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 0] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 0] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 0] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 0] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "cost[i][j] = houses[mid]*(mid-i+1)-(prefix[mid+1]-prefix[i])",
      "mutated_line": "cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + -1] - prefix[i])",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + -1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 2] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 2] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 0] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 0] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 0] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 0] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + -1] - prefix[mid + 1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + -1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 2] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 2] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 0] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 0] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + 0] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 0] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "cost[i][j] += (prefix[j+1]-prefix[mid+1])-houses[mid]*(j-mid)",
      "mutated_line": "cost[i][j] += prefix[j + 1] - prefix[mid + -1] - houses[mid] * (j - mid)",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + -1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 2))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 2))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 0))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 0))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 0))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > 0))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > -1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 1] + (k > -1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j + 1] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j + 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j * 1] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j * 1] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 2] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 2] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 0] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 0] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - 0] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - 0] + (k > 1))\n    return dp[-1] - (k > 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[j] = min(dp[j], dp[i] + cost[i][j-1] + (k > 1))",
      "mutated_line": "dp[j] = min(dp[j], dp[i] + cost[i][j - -1] + (k > 1))",
      "code": "def minDistance(houses: list[int], k: int) -> int:\n    houses.sort()\n    n = len(houses)\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + houses[i]\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            mid = (i + j) // 2\n            cost[i][j] = houses[mid] * (mid - i + 1) - (prefix[mid + 1] - prefix[i])\n            cost[i][j] += prefix[j + 1] - prefix[mid + 1] - houses[mid] * (j - mid)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for j in range(1, n + 1):\n        for i in range(j):\n            if dp[i] != float('inf'):\n                dp[j] = min(dp[j], dp[i] + cost[i][j - -1] + (k > 1))\n    return dp[-1] - (k > 1)"
    }
  ]
}