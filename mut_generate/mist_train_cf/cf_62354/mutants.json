{
  "task_id": "cf_62354",
  "entry_point": "is_sorted",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_sorted(input_list):\n    \"\"\"\"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return False\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) + 1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) + 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) * 1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) * 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] >= input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] >= input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] <= input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] <= input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] != input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] != input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 2):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 2):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 0):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 0):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 0):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 0):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - -1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - -1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return True\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) + 1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) + 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) * 1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) * 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] >= input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] >= input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] <= input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] <= input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] != input_list[i + 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] != input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i - 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i - 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i * 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i * 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 2):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 2):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 0):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 0):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - 0):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 0):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(len(input_list) - 1):",
      "mutated_line": "for i in range(len(input_list) - -1):",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - -1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 2]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 2]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 0]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 0]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 0]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 0]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + -1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + -1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i - 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i - 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i * 1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i * 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 2]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 2]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 0]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 0]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + 0]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 0]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if input_list[i] > input_list[i + 1]:",
      "mutated_line": "if input_list[i] > input_list[i + -1]:",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + -1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i - 1]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i - 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i * 1]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i * 1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i - 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i - 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i * 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i * 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 2]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 2]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 0]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 0]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 0]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 0]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + -1]) = (input_list[i + 1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + -1]) = (input_list[i + 1], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i + 2], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 2], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i + 0], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 0], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i + 0], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + 0], input_list[i])\n    return input_list"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]",
      "mutated_line": "(input_list[i], input_list[i + 1]) = (input_list[i + -1], input_list[i])",
      "code": "def is_sorted(input_list):\n    \"\"\"\n    This function tests whether a list is sorted in ascending order. \n    It iterates over the list and checks each pair of elements.\n    If it find any pair out of order, it immediately returns False. \n    If it finishes iterating over the input_list without finding any elements out of order, it returns True.\n    \"\"\"\n    for i in range(len(input_list) - 1):\n        if input_list[i] > input_list[i + 1]:\n            return False\n    return True\n\ndef bubble_sort(input_list):\n    \"\"\"\n    This is an implementation of the optimized bubble sort algorithm. \n    It has a while loop that continues until the list is sorted. \n    Inside this while loop, it has a for loop that iterates over each pair of adjacent elements in the list\n    If it finds a pair that are out of order, it swaps them.\n    Then it checks if the list is sorted. If it is, it breaks out of the while loop early. \n    This is the optimization comes into play If the list is already sorted then it doesn't need to continue the sorting process.\n    \"\"\"\n    while not is_sorted(input_list):\n        for i in range(len(input_list) - 1):\n            if input_list[i] > input_list[i + 1]:\n                (input_list[i], input_list[i + 1]) = (input_list[i + -1], input_list[i])\n    return input_list"
    }
  ]
}