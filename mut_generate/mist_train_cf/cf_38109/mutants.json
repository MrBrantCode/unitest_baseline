{
  "task_id": "cf_38109",
  "entry_point": "combinationSum",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain != 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain != 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtracking(0, target, [], solution)",
      "mutated_line": "backtracking(1, target, [], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(1, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtracking(0, target, [], solution)",
      "mutated_line": "backtracking(-1, target, [], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(-1, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "backtracking(0, target, [], solution)",
      "mutated_line": "backtracking(1, target, [], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(1, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == 1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 1:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == -1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == -1:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if remain == 0:",
      "mutated_line": "if remain == 1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 1:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] > 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] > 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] < 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] < 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] == 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] == 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain + candidates[i] >= 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain + candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain * candidates[i] >= 0:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain * candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] >= 1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 1:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] >= -1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= -1:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if remain - candidates[i] >= 0:",
      "mutated_line": "if remain - candidates[i] >= 1:",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 1:\n                backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)",
      "mutated_line": "backtracking(i, remain + candidates[i], sub_solution + [candidates[i]], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain + candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)",
      "mutated_line": "backtracking(i, remain * candidates[i], sub_solution + [candidates[i]], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain * candidates[i], sub_solution + [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)",
      "mutated_line": "backtracking(i, remain - candidates[i], sub_solution - [candidates[i]], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution - [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "backtracking(i, remain - candidates[i], sub_solution + [candidates[i]], solution)",
      "mutated_line": "backtracking(i, remain - candidates[i], sub_solution * [candidates[i]], solution)",
      "code": "from typing import List\n\ndef combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n\n    def backtracking(start_index, remain, sub_solution, solution):\n        if remain == 0:\n            solution.append(sub_solution[:])\n            return\n        for i in range(start_index, len(candidates)):\n            if remain - candidates[i] >= 0:\n                backtracking(i, remain - candidates[i], sub_solution * [candidates[i]], solution)\n    candidates.sort()\n    solution = []\n    backtracking(0, target, [], solution)\n    return solution"
    }
  ]
}