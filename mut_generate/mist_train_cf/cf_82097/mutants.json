{
  "task_id": "cf_82097",
  "entry_point": "email_spam_classifier",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob -= log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob -= log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob -= log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob -= log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return spam_prob > non_spam_prob",
      "mutated_line": "return spam_prob >= non_spam_prob",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob >= non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return spam_prob > non_spam_prob",
      "mutated_line": "return spam_prob <= non_spam_prob",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob <= non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "return spam_prob > non_spam_prob",
      "mutated_line": "return spam_prob != non_spam_prob",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob != non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "text = re.sub(r'<.*?>', '', text)  # Remove HTML tags",
      "mutated_line": "text = re.sub('', '', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "text = re.sub(r'<.*?>', '', text)  # Remove HTML tags",
      "mutated_line": "text = re.sub('<.*?>', 'MUTATED', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', 'MUTATED', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "text = re.sub(r'\\W', ' ', text)  # Remove non-word characters",
      "mutated_line": "text = re.sub('', ' ', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "text = re.sub(r'\\W', ' ', text)  # Remove non-word characters",
      "mutated_line": "text = re.sub('\\\\W', '', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', '', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "text = re.sub(r'\\s+', ' ', text)  # Remove multiple spaces",
      "mutated_line": "text = re.sub('', ' ', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "text = re.sub(r'\\s+', ' ', text)  # Remove multiple spaces",
      "mutated_line": "text = re.sub('\\\\s+', '', text)",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', '', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "features[word] += 1",
      "mutated_line": "features[word] -= 1",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] -= 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "spam_prob = log(len(spam_emails) * (len(spam_emails) + len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) * (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "spam_prob = log(len(spam_emails) // (len(spam_emails) + len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) // (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "non_spam_prob = log(len(non_spam_emails) * (len(spam_emails) + len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) * (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "non_spam_prob = log(len(non_spam_emails) // (len(spam_emails) + len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) // (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "features[word] += 1",
      "mutated_line": "features[word] += 2",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 2\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "features[word] += 1",
      "mutated_line": "features[word] += 0",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 0\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "features[word] += 1",
      "mutated_line": "features[word] += 0",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 0\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "features[word] += 1",
      "mutated_line": "features[word] += -1",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += -1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) - len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) - len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "spam_prob = log(len(spam_emails) / (len(spam_emails) * len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) * len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) - len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) - len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))",
      "mutated_line": "non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) * len(non_spam_emails)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) * len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 1) * (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) * (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 1) // (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) // (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 1) * (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) * (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 1) // (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) // (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] - 1) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] - 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log(spam_features[word] * 1 / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log(spam_features[word] * 1 / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) - len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) - len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) * len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) * len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] - 1) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] - 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log(non_spam_features[word] * 1 / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log(non_spam_features[word] * 1 / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) - len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) - len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) * len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) * len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 2) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 2) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 0) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 0) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + 0) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 0) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))",
      "mutated_line": "spam_prob += log((spam_features[word] + -1) / (len(spam_features) + len(non_spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + -1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 2) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 2) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 0) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 0) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + 0) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + 0) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "non_spam_prob += log((non_spam_features[word] + 1) / (len(non_spam_features) + len(spam_features)))",
      "mutated_line": "non_spam_prob += log((non_spam_features[word] + -1) / (len(non_spam_features) + len(spam_features)))",
      "code": "import re\nfrom collections import defaultdict\nfrom math import log\n\ndef email_spam_classifier(email_text, spam_emails, non_spam_emails):\n    \"\"\"\n    Classify an email as spam or not using a naive Bayes classifier.\n\n    Parameters:\n    email_text (str): The text of the email to classify.\n    spam_emails (list): A list of spam emails for training.\n    non_spam_emails (list): A list of non-spam emails for training.\n\n    Returns:\n    bool: True if the email is classified as spam, False otherwise.\n    \"\"\"\n\n    def clean_text(text):\n        text = text.lower()\n        text = re.sub('<.*?>', '', text)\n        text = re.sub('\\\\W', ' ', text)\n        text = re.sub('\\\\s+', ' ', text)\n        return text\n    email_text = clean_text(email_text)\n\n    def extract_features(emails):\n        features = defaultdict(int)\n        for email in emails:\n            email = clean_text(email)\n            words = email.split()\n            for word in words:\n                features[word] += 1\n        return features\n    spam_features = extract_features(spam_emails)\n    non_spam_features = extract_features(non_spam_emails)\n\n    def classify(email, spam_features, non_spam_features):\n        spam_prob = log(len(spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        non_spam_prob = log(len(non_spam_emails) / (len(spam_emails) + len(non_spam_emails)))\n        for word in email.split():\n            spam_prob += log((spam_features[word] + 1) / (len(spam_features) + len(non_spam_features)))\n            non_spam_prob += log((non_spam_features[word] + -1) / (len(non_spam_features) + len(spam_features)))\n        return spam_prob > non_spam_prob\n    return classify(email_text, spam_features, non_spam_features)"
    }
  ]
}