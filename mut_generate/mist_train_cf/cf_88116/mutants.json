{
  "task_id": "cf_88116",
  "entry_point": "parse_ip_address",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) == 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "binary_sum = 0",
      "mutated_line": "binary_sum = 1",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 1\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "binary_sum = 0",
      "mutated_line": "binary_sum = -1",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = -1\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "binary_sum = 0",
      "mutated_line": "binary_sum = 1",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 1\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "octets = ip_address.split(\".\")",
      "mutated_line": "octets = ip_address.split('')",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 5:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 3:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 0:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 1:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(octets) != 4:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != -4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return \"Invalid IP address\"",
      "mutated_line": "return ''",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return ''\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum -= int(binary, 2)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum -= int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 and octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int <= 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int >= 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int != 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int >= 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int <= 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int != 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return \"Invalid IP address\"",
      "mutated_line": "return ''",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return ''\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[2:].zfill(9)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(9)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[2:].zfill(7)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(7)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[2:].zfill(0)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(0)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[2:].zfill(1)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(1)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[2:].zfill(-8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(-8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum += int(binary, 3)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 3)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum += int(binary, 1)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 1)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum += int(binary, 0)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 0)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum += int(binary, 1)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 1)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "binary_sum += int(binary, 2)",
      "mutated_line": "binary_sum += int(binary, -2)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, -2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return \"Invalid IP address\"",
      "mutated_line": "return ''",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return ''\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 1 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < -1 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 1 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 256:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 254:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 0:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 1:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if octet_int < 0 or octet_int > 255:",
      "mutated_line": "return 'Invalid IP address'",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > -255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[3:].zfill(8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[3:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[1:].zfill(8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[1:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[0:].zfill(8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[0:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[1:].zfill(8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[1:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "binary = bin(octet_int)[2:].zfill(8)",
      "mutated_line": "binary = bin(octet_int)[-2:].zfill(8)",
      "code": "def parse_ip_address(ip_address):\n    \"\"\"\n    This function takes a string representing an IP address as input, \n    splits it into its octets, converts each octet into its binary representation \n    using bitwise operations, and returns the sum of all the binary values as an integer.\n    \n    Args:\n    ip_address (str): A string representing an IP address.\n    \n    Returns:\n    int: The sum of all the binary values as an integer if the IP address is valid.\n    str: \"Invalid IP address\" if the input IP address is invalid.\n    \"\"\"\n    octets = ip_address.split('.')\n    if len(octets) != 4:\n        return 'Invalid IP address'\n    binary_sum = 0\n    for octet in octets:\n        try:\n            octet_int = int(octet)\n            if octet_int < 0 or octet_int > 255:\n                return 'Invalid IP address'\n            binary = bin(octet_int)[-2:].zfill(8)\n            binary_sum += int(binary, 2)\n        except ValueError:\n            return 'Invalid IP address'\n    return binary_sum"
    }
  ]
}