{
  "task_id": "cf_58833",
  "entry_point": "find_numbers",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) <= 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) >= 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) != 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) <= 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) <= 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) >= 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) >= 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) != 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) != 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 2 != 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 != 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 4:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 2:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 0:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 1:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "return 'Not enough even numbers.'",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < -3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return \"Not enough even numbers.\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return ''\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) < 4:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 4:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) < 2:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 2:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) < 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 0:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) < 1:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 1:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "if len(max_heap) < -3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < -3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return \"Not enough odd numbers.\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return ''\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num * 2 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num * 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num + 2 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num + 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 2 == 1:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 1:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 2 == -1:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == -1:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 2 == 1:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 1:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) <= 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) <= 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) >= 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) >= 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) != 3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) != 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) <= 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) >= 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) != 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 3 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 3 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 1 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 1 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 0 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 0 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % 1 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 1 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if num % 2 == 0:  # even numbers",
      "mutated_line": "if num % -2 == 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % -2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) < 4:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 4:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) < 2:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 2:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) < 0:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 0:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) < 1:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 1:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(min_heap) < 3:",
      "mutated_line": "if len(min_heap) < -3:",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < -3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 4:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 2:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 0:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 1:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if len(max_heap) < 3:",
      "mutated_line": "heapq.heappush(max_heap, num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < -3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "return sorted([-i for i in min_heap]), sorted(max_heap, reverse=True)",
      "mutated_line": "return (sorted([+i for i in min_heap]), sorted(max_heap, reverse=True))",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([+i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return sorted([-i for i in min_heap]), sorted(max_heap, reverse=True)",
      "mutated_line": "return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=False))",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=False))"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "heapq.heappush(min_heap, -num)",
      "mutated_line": "heapq.heappush(min_heap, +num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, +num)\n            else:\n                heapq.heappushpop(min_heap, -num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "heapq.heappushpop(min_heap, -num)",
      "mutated_line": "heapq.heappushpop(min_heap, +num)",
      "code": "import heapq\n\ndef find_numbers(array):\n    min_heap = []\n    max_heap = []\n    for num in array:\n        if num % 2 == 0:\n            if len(min_heap) < 3:\n                heapq.heappush(min_heap, -num)\n            else:\n                heapq.heappushpop(min_heap, +num)\n        elif len(max_heap) < 3:\n            heapq.heappush(max_heap, num)\n        else:\n            heapq.heappushpop(max_heap, num)\n    if len(min_heap) < 3:\n        return 'Not enough even numbers.'\n    if len(max_heap) < 3:\n        return 'Not enough odd numbers.'\n    return (sorted([-i for i in min_heap]), sorted(max_heap, reverse=True))"
    }
  ]
}