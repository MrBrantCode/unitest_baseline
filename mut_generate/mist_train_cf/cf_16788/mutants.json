{
  "task_id": "cf_16788",
  "entry_point": "knapsack_fractional",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "total_value = 0",
      "mutated_line": "total_value = 1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 1\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "total_value = 0",
      "mutated_line": "total_value = -1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = -1\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "total_value = 0",
      "mutated_line": "total_value = 1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 1\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = 1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 1\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = -1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = -1\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "total_weight = 0",
      "mutated_line": "total_weight = 1",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 1\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity >= 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity >= 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity <= 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity <= 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity != 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity != 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "total_value += value * max_quantity",
      "mutated_line": "total_value -= value * max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value -= value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "total_weight += weight * max_quantity",
      "mutated_line": "total_weight -= weight * max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight -= weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "capacity -= weight * max_quantity",
      "mutated_line": "capacity += weight * max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity += weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "k -= max_quantity",
      "mutated_line": "k += max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k += max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if max_quantity < quantity:",
      "mutated_line": "if max_quantity <= quantity:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity <= quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if max_quantity < quantity:",
      "mutated_line": "if max_quantity >= quantity:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity >= quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if max_quantity < quantity:",
      "mutated_line": "if max_quantity != quantity:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity != quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "total_value += value * fractional_quantity",
      "mutated_line": "total_value -= value * fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value -= value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "total_weight += weight * fractional_quantity",
      "mutated_line": "total_weight -= weight * fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight -= weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "capacity -= weight * fractional_quantity",
      "mutated_line": "capacity += weight * fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity += weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "k -= fractional_quantity",
      "mutated_line": "k += fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k += fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=False)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=False)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "max_quantity = min(k, quantity, capacity // weight)",
      "mutated_line": "max_quantity = min(k, quantity, capacity / weight)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity / weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "max_quantity = min(k, quantity, capacity // weight)",
      "mutated_line": "max_quantity = min(k, quantity, capacity * weight)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity * weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity > 1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 1:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity > -1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > -1:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if max_quantity > 0:",
      "mutated_line": "if max_quantity > 1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 1:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total_value += value * max_quantity",
      "mutated_line": "total_value += value / max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value / max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total_value += value * max_quantity",
      "mutated_line": "total_value += value + max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value + max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total_value += value * max_quantity",
      "mutated_line": "total_value += value ** max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value ** max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_weight += weight * max_quantity",
      "mutated_line": "total_weight += weight / max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight / max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_weight += weight * max_quantity",
      "mutated_line": "total_weight += weight + max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight + max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "total_weight += weight * max_quantity",
      "mutated_line": "total_weight += weight ** max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight ** max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "capacity -= weight * max_quantity",
      "mutated_line": "capacity -= weight / max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight / max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "capacity -= weight * max_quantity",
      "mutated_line": "capacity -= weight + max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight + max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "capacity -= weight * max_quantity",
      "mutated_line": "capacity -= weight ** max_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight ** max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 0 and k == 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 and k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "total_value += value * fractional_quantity",
      "mutated_line": "total_value += value / fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value / fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "total_value += value * fractional_quantity",
      "mutated_line": "total_value += value + fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value + fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "total_value += value * fractional_quantity",
      "mutated_line": "total_value += value ** fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value ** fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "total_weight += weight * fractional_quantity",
      "mutated_line": "total_weight += weight / fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight / fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "total_weight += weight * fractional_quantity",
      "mutated_line": "total_weight += weight + fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight + fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "total_weight += weight * fractional_quantity",
      "mutated_line": "total_weight += weight ** fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight ** fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity -= weight * fractional_quantity",
      "mutated_line": "capacity -= weight / fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight / fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity -= weight * fractional_quantity",
      "mutated_line": "capacity -= weight + fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight + fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity -= weight * fractional_quantity",
      "mutated_line": "capacity -= weight ** fractional_quantity",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight ** fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] * x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] * x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] // x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] // x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity != 0 or k == 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity != 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 0 or k != 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k != 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "fractional_quantity = min(remaining_capacity / weight, remaining_quantity)",
      "mutated_line": "fractional_quantity = min(remaining_capacity * weight, remaining_quantity)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity * weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "fractional_quantity = min(remaining_capacity / weight, remaining_quantity)",
      "mutated_line": "fractional_quantity = min(remaining_capacity // weight, remaining_quantity)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity // weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 1 or k == 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 1 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == -1 or k == 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == -1 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 1 or k == 0:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 1 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 0 or k == 1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 1:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 0 or k == -1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == -1:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if capacity == 0 or k == 0:",
      "mutated_line": "if capacity == 0 or k == 1:",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 1:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[2] / x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[2] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[0] / x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[0] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[0] / x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[0] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[-1] / x[0], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[-1] / x[0], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[1], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[1], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[-1], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[-1], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[0], reverse=True)",
      "mutated_line": "sorted_items = sorted(items, key=lambda x: x[1] / x[1], reverse=True)",
      "code": "def knapsack_fractional(items, capacity, k):\n    sorted_items = sorted(items, key=lambda x: x[1] / x[1], reverse=True)\n    total_value = 0\n    total_weight = 0\n    for (weight, value, quantity) in sorted_items:\n        max_quantity = min(k, quantity, capacity // weight)\n        if max_quantity > 0:\n            total_value += value * max_quantity\n            total_weight += weight * max_quantity\n            capacity -= weight * max_quantity\n            k -= max_quantity\n            if capacity == 0 or k == 0:\n                break\n        if max_quantity < quantity:\n            remaining_capacity = capacity\n            remaining_quantity = k\n            fractional_quantity = min(remaining_capacity / weight, remaining_quantity)\n            total_value += value * fractional_quantity\n            total_weight += weight * fractional_quantity\n            capacity -= weight * fractional_quantity\n            k -= fractional_quantity\n    return total_value"
    }
  ]
}