{
  "task_id": "cf_29581",
  "entry_point": "custom_nll_loss",
  "mutant_count": 23,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "nll_loss /= batch_size",
      "mutated_line": "nll_loss *= batch_size",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss *= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "grad_predicted_probs /= batch_size",
      "mutated_line": "grad_predicted_probs *= batch_size",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs *= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nll_loss = 0.0",
      "mutated_line": "nll_loss = 1.0",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 1.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nll_loss = 0.0",
      "mutated_line": "nll_loss = -1.0",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = -1.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "nll_loss = 0.0",
      "mutated_line": "nll_loss = 1",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 1\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "nll_loss -= np.log(probs[true_label])",
      "mutated_line": "nll_loss += np.log(probs[true_label])",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss += np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] -= 1 / probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] -= 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "batch_size = predicted_probs.shape[0]",
      "mutated_line": "batch_size = predicted_probs.shape[1]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[1]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "batch_size = predicted_probs.shape[0]",
      "mutated_line": "batch_size = predicted_probs.shape[-1]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[-1]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "batch_size = predicted_probs.shape[0]",
      "mutated_line": "batch_size = predicted_probs.shape[1]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[1]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = -1 * probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 * probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = -1 // probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 // probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += 1 * probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 * probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += 1 // probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 1 // probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = +1 / probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = +1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += 2 / probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 2 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += 0 / probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 0 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += 0 / probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += 0 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "grad_predicted_probs[i, true_label] += 1 / probs[true_label]",
      "mutated_line": "grad_predicted_probs[i, true_label] += -1 / probs[true_label]",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -1 / probs\n        grad_predicted_probs[i, true_label] += -1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = -2 / probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -2 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = -0 / probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -0 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = -0 / probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = -0 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "grad_predicted_probs[i] = -1 / probs",
      "mutated_line": "grad_predicted_probs[i] = --1 / probs",
      "code": "import numpy as np\n\ndef custom_nll_loss(predicted_probs, true_labels):\n    batch_size = predicted_probs.shape[0]\n    nll_loss = 0.0\n    grad_predicted_probs = np.zeros_like(predicted_probs)\n    for i in range(batch_size):\n        true_label = true_labels[i]\n        probs = predicted_probs[i]\n        nll_loss -= np.log(probs[true_label])\n        grad_predicted_probs[i] = --1 / probs\n        grad_predicted_probs[i, true_label] += 1 / probs[true_label]\n    nll_loss /= batch_size\n    grad_predicted_probs /= batch_size\n    return (nll_loss, grad_predicted_probs)"
    }
  ]
}