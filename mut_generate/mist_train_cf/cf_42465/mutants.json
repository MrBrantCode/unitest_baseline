{
  "task_id": "cf_42465",
  "entry_point": "wmdistance",
  "mutant_count": 141,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(2, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(0, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(0, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(-1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n - 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n * 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] - distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] - distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] * distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] * distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(2, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(0, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(0, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(-1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m - 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m * 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] - distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] - distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] * distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] * distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(0, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(-1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n - 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n * 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if word1 in word_vectors and word2 in word_vectors:",
      "mutated_line": "if word1 in word_vectors or word2 in word_vectors:",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors or word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n - 1, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n - 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n * 1, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n * 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m - 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m - 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m * 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m * 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 2):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 0):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 0):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + -1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][1] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][1] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][-1] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][-1] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][1] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][1] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 2):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 0):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 0):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + -1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 2):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 0):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + -1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(2, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(2, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(0, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(-1, m + 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(-1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m - 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m - 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m * 1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m * 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] - min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] - min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] * min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] * min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if word1 in word_vectors and word2 in word_vectors:",
      "mutated_line": "if word1 not in word_vectors and word2 in word_vectors:",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 not in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if word1 in word_vectors and word2 in word_vectors:",
      "mutated_line": "if word1 in word_vectors and word2 not in word_vectors:",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 not in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 2, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 2, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 0, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 0, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 0, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 0, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + -1, m + 1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + -1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m + 2))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 2))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m + 0))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 0))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m + 0))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 0))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = np.zeros((n + 1, m + 1))",
      "mutated_line": "dp = np.zeros((n + 1, m + -1))",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + -1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][1] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][1] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][-1] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][-1] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][1] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][1] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][1]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][-1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][-1]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][1]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[-1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[-1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[1][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j + 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j + 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j * 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j * 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j + 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j + 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j * 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j * 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 2):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 2):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + 0):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 0):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(1, m + 1):",
      "mutated_line": "for j in range(1, m + -1):",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + -1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])",
      "mutated_line": "distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] + word_vectors[word2])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] + word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])",
      "mutated_line": "distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] * word_vectors[word2])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] * word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i + 1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i + 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i * 1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i * 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i + 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i + 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i * 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i * 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[1][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[1][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[-1][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[-1][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[1][j - 1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[1][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 2] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 2] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 0] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 0] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 0] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 0] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - -1] + distance_matrix[0][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - -1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[1][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[1][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[-1][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[-1][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[1][j - 1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[1][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 2]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 2]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 0]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 0]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]",
      "mutated_line": "dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - -1]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - -1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j + 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j + 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j * 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j * 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 2][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 2][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 0][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 0][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 0][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 0][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - -1][0] + distance_matrix[i - 1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - -1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 2][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 2][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 0][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 0][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 0][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 0][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]",
      "mutated_line": "dp[i][0] = dp[i - 1][0] + distance_matrix[i - -1][0]",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - -1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i + 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i + 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i * 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i * 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 2] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 2] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 0] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 0] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 0] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 0] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - -1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - -1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j + 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j + 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j * 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j * 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j + 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j + 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j * 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j * 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 2][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 2][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 0][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 0][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 0][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 0][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - -1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - -1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i + 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i + 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i * 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i * 1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 2], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 2], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 0], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 0], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 0], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 0], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - -1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - -1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i + 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i + 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i * 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i * 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 2])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 2])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 0])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 0])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 0])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 0])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - -1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - -1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 2][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 2][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 0][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 0][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 0][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 0][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - -1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - -1][j - 1], dp[i - 1][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 2][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 2][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 0][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 0][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 0][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 0][j], dp[i][j - 1])\n    return dp[n][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])",
      "mutated_line": "dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - -1][j], dp[i][j - 1])",
      "code": "import numpy as np\n\ndef wmdistance(word_vectors, set1, set2):\n    distance_matrix = np.zeros((len(set1), len(set2)))\n    for (i, word1) in enumerate(set1):\n        for (j, word2) in enumerate(set2):\n            if word1 in word_vectors and word2 in word_vectors:\n                distance_matrix[i, j] = np.linalg.norm(word_vectors[word1] - word_vectors[word2])\n    n = len(set1)\n    m = len(set2)\n    dp = np.zeros((n + 1, m + 1))\n    for i in range(1, n + 1):\n        dp[i][0] = dp[i - 1][0] + distance_matrix[i - 1][0]\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + distance_matrix[0][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = distance_matrix[i - 1][j - 1] + min(dp[i - 1][j - 1], dp[i - -1][j], dp[i][j - 1])\n    return dp[n][m]"
    }
  ]
}