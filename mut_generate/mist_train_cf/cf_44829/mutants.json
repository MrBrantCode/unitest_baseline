{
  "task_id": "cf_44829",
  "entry_point": "maxSumPath",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = False\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return \"Error: Chessboard must be a list\"",
      "mutated_line": "return ''",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return ''\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return \"Error: Chessboard must be a square\"",
      "mutated_line": "return ''",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return ''\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 < k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 < k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 > k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 > k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 == k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 == k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return \"Error: Steps must be between 1 and N*N\"",
      "mutated_line": "return ''",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return ''\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_sum = [0]",
      "mutated_line": "max_sum = [1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [1]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_sum = [0]",
      "mutated_line": "max_sum = [-1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [-1]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "max_sum = [0]",
      "mutated_line": "max_sum = [1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [1]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [[False]*N for _ in range(N)]",
      "mutated_line": "visited = [[False] / N for _ in range(N)]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] / N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [[False]*N for _ in range(N)]",
      "mutated_line": "visited = [[False] + N for _ in range(N)]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] + N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [[False]*N for _ in range(N)]",
      "mutated_line": "visited = [[False] ** N for _ in range(N)]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] ** N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k != 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N + 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N * 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N + 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N + 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N * 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N * 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N + 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N + 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N * 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N * 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k + 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k + 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k * 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k * 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max_path[0]",
      "mutated_line": "return max_path[1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max_path[0]",
      "mutated_line": "return max_path[-1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max_path[0]",
      "mutated_line": "return max_path[1]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 2 <= k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 2 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 0 <= k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 0 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 0 <= k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 0 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not -1 <= k <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not -1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 <= k <= N / N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N / N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 <= k <= N + N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N + N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if not 1 <= k <= N*N:",
      "mutated_line": "if not 1 <= k <= N ** N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N ** N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N or 0 <= ny < N or (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N or 0 <= ny < N or (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 1:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == -1:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 1:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum >= max_sum[0]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum >= max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum <= max_sum[0]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum <= max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum != max_sum[0]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum != max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = False\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited[nx][ny] = False",
      "mutated_line": "visited[nx][ny] = True",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = True\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N + 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N * 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 2] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 0] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 0] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - -1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 2, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 2, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 0, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 0, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 0, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 0, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - -1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - -1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 2, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 2, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 0, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 0, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 0, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 0, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - -1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - -1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 2, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 2, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 0, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 0, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 0, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 0, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - -1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - -1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N + 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N + 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N * 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N * 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if not all(len(row) == N for row in chessboard):",
      "mutated_line": "if not all((len(row) != N for row in chessboard)):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) != N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 < square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 < square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 > square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 > square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 == square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 == square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return \"Error: Square values must be between 1 and N*N\"",
      "mutated_line": "return ''",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return ''\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited = [[False]*N for _ in range(N)]",
      "mutated_line": "visited = [[True] * N for _ in range(N)]",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[True] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x - 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x - 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x * 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x * 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x + 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x + 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x * 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x * 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y - 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y - 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y * 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y * 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y + 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y + 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y * 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y * 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 < nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 < nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 > nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 > nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 == nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 == nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 < ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 < ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 > ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 > ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 == ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 == ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k + 1, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k + 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k * 1, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k * 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - 1, path, path_sum - chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum - chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - 1, path, path_sum * chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum * chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 2][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 0][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 0][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visited[N-1][N-1] = True",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - -1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N + 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N + 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N * 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N * 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N + 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N + 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N * 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N * 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 2])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 2])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 0])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 0])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 0])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 0])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - -1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - -1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 2 <= square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 2 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 0 <= square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 0 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 0 <= square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 0 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not -1 <= square <= N * N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not -1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 <= square <= N / N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N / N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 <= square <= N + N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N + N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if not 1 <= square <= N*N:",
      "mutated_line": "if not 1 <= square <= N ** N:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N ** N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 2, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 2, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 0, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 0, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 0, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 0, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + -1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + -1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 2, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 2, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 0, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 0, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 0, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 0, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - -1, y), (x, y + 1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - -1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 2), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 2), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 0), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 0), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 0), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 0), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + -1), (x, y - 1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + -1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 2)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 2)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 0)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 0)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 0)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 0)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:",
      "mutated_line": "for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - -1)]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - -1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if -1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if -1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and -1 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and -1 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum > max_sum[1]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[1]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum > max_sum[-1]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[-1]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if path_sum > max_sum[0]:",
      "mutated_line": "if path_sum > max_sum[1]:",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[1]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_sum[0] = path_sum",
      "mutated_line": "max_sum[1] = path_sum",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[1] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_sum[0] = path_sum",
      "mutated_line": "max_sum[-1] = path_sum",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[-1] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_sum[0] = path_sum",
      "mutated_line": "max_sum[1] = path_sum",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[1] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_path[0] = path.copy()",
      "mutated_line": "max_path[1] = path.copy()",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[1] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_path[0] = path.copy()",
      "mutated_line": "max_path[-1] = path.copy()",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[-1] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "max_path[0] = path.copy()",
      "mutated_line": "max_path[1] = path.copy()",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[1] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - 2, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 2, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - 0, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 0, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - 0, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 0, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dfs(nx, ny, k-1, path, path_sum + chessboard[nx][ny])",
      "mutated_line": "dfs(nx, ny, k - -1, path, path_sum + chessboard[nx][ny])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - -1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N + 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N + 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N * 1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N * 1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 2]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 2]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 0]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 0]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 0]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 0]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - -1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - -1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 2][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 2][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 0][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 0][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 0][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - 0][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - -1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 1][N - 1]], chessboard[N - -1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 2][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 2][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 0][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 0][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - 0][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - 0][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dfs(N-1, N-1, k-1, [chessboard[N-1][N-1]], chessboard[N-1][N-1])",
      "mutated_line": "dfs(N - 1, N - 1, k - 1, [chessboard[N - -1][N - 1]], chessboard[N - 1][N - 1])",
      "code": "def maxSumPath(chessboard, k):\n    if not isinstance(chessboard, list):\n        return 'Error: Chessboard must be a list'\n    N = len(chessboard)\n    if not all((len(row) == N for row in chessboard)):\n        return 'Error: Chessboard must be a square'\n    if not 1 <= k <= N * N:\n        return 'Error: Steps must be between 1 and N*N'\n    for row in chessboard:\n        for square in row:\n            if not 1 <= square <= N * N:\n                return 'Error: Square values must be between 1 and N*N'\n    max_sum = [0]\n    max_path = [None]\n    visited = [[False] * N for _ in range(N)]\n\n    def next_positions(x, y):\n        for (nx, ny) in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n            if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                yield (nx, ny)\n\n    def dfs(x, y, k, path, path_sum):\n        if k == 0:\n            if path_sum > max_sum[0]:\n                max_sum[0] = path_sum\n                max_path[0] = path.copy()\n            return\n        for (nx, ny) in next_positions(x, y):\n            visited[nx][ny] = True\n            path.append(chessboard[nx][ny])\n            dfs(nx, ny, k - 1, path, path_sum + chessboard[nx][ny])\n            visited[nx][ny] = False\n            path.pop()\n    visited[N - 1][N - 1] = True\n    dfs(N - 1, N - 1, k - 1, [chessboard[N - -1][N - 1]], chessboard[N - 1][N - 1])\n    return max_path[0]"
    }
  ]
}