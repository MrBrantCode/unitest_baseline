{
  "task_id": "cf_27991",
  "entry_point": "calculate_accuracy",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Z1 = np.dot(W1, X) + B1",
      "mutated_line": "Z1 = np.dot(W1, X) - B1",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) - B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "Z1 = np.dot(W1, X) + B1",
      "mutated_line": "Z1 = np.dot(W1, X) * B1",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) * B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "Z2 = np.dot(W2, A1) + B2",
      "mutated_line": "Z2 = np.dot(W2, A1) - B2",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) - B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "Z2 = np.dot(W2, A1) + B2",
      "mutated_line": "Z2 = np.dot(W2, A1) * B2",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) * B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 * (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 * (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 // (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 // (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 2 / (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 2 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 0 / (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 0 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 0 / (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 0 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = -1 / (1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = -1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (1 - np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 - np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (1 * np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 * np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "accuracy = np.mean(Y_predicted == Y)",
      "mutated_line": "accuracy = np.mean(Y_predicted != Y)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted != Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (2 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (2 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (0 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (0 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (0 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (0 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (-1 + np.exp(-Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (-1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 >= 0.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 >= 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 <= 0.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 <= 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 != 0.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 != 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "A2 = 1 / (1 + np.exp(-Z2))",
      "mutated_line": "A2 = 1 / (1 + np.exp(+Z2))",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(+Z2))\n    Y_predicted = (A2 > 0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 > 1.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 1.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 > -0.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > -0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 > 0).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 0).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 > 1).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > 1).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "Y_predicted = (A2 > 0.5).astype(int)",
      "mutated_line": "Y_predicted = (A2 > -0.5).astype(int)",
      "code": "import numpy as np\n\ndef calculate_accuracy(X, W1, B1, W2, B2, Y):\n    \"\"\"\n    Calculates the accuracy of the predictions.\n\n    Args:\n    X: NumPy array of shape (n, m), where n is the number of features and m is the number of examples.\n    W1: NumPy array of shape (n_h, n), where n_h is the number of hidden units and n is the number of features.\n    B1: NumPy array of shape (n_h, 1), where n_h is the number of hidden units.\n    W2: NumPy array of shape (1, n_h), where n_h is the number of hidden units.\n    B2: NumPy array of shape (1, 1).\n    Y: NumPy array of true labels of shape (m, ).\n\n    Returns:\n    Accuracy of the predictions.\n    \"\"\"\n    Z1 = np.dot(W1, X) + B1\n    A1 = np.tanh(Z1)\n    Z2 = np.dot(W2, A1) + B2\n    A2 = 1 / (1 + np.exp(-Z2))\n    Y_predicted = (A2 > -0.5).astype(int)\n    accuracy = np.mean(Y_predicted == Y)\n    return accuracy"
    }
  ]
}